<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ucore Lab04</title>
      <link href="/2020/05/16/ucore-lab04/"/>
      <url>/2020/05/16/ucore-lab04/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-lab04"><a href="#Ucore-lab04" class="headerlink" title="Ucore lab04"></a>Ucore lab04</h1><h1 id="一、-操作系统原理"><a href="#一、-操作系统原理" class="headerlink" title="一、    操作系统原理"></a>一、    操作系统原理</h1><h2 id="1-1、进程控制块proc-struct"><a href="#1-1、进程控制块proc-struct" class="headerlink" title="1.1、进程控制块proc_struct"></a>1.1、进程控制块proc_struct</h2><p>进程控制块<code>proc_struct</code>几个比较重要的域：</p><ul><li><code>mm</code> ： 内存管理的信息， 包括内存映射列表、 页表指针等。 mm里有个很重要的项pgdir， 记录的是该进程使用的一级页表的物理地址。</li><li><code>state</code>： 进程所处的状态。</li><li><code>parent</code> ： 用户进程的父进程（ 创建它的进程） 。 在所有进程中， 只有一个进程没有父进程， 就是内核创建的第一个内核线程idleproc。 内核根据这个父子关系建立进程的树形结构， 用于维护一些特殊的操作， 例如确定哪些进程是否可以对另外一些进程进行什么样的操作等等</li><li><code>context</code>： 进程的上下文， 用于进程切换（ 参见switch.S） 。 在 ucore 中， 所有的进程在内核中也是相对独立的（ 例如独立的内核堆栈以及上下文等等） 。 使用 context 保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。 实际利用context进行上下文切换的函数是switch_to， 在kern/process/switch.S中定义。</li><li><code>tf</code>： 中断帧的指针， 总是指向内核栈的某个位置： 当进程从用户空间跳到内核空间时， 中断帧记录了进程在被中断前的状态。 当内核需要跳回用户空间时， 需要调整中断帧以恢复让进程继续执行的各寄存器值。 除此之外， ucore 内核允许嵌套中断。 因此为了保证嵌套中断发生时tf 总是能够指向当前的 trapframe， ucore 在内核栈上维护了 tf 的链</li><li><code>cr3</code>:  保存页表的物理地址， 目的就是进程切换的时候方便直接使用 lcr3 实现页表切换， 避免每次都根据 mm 来计算 cr3。 mm 数据结构是用来实现用户空间的虚存管理的， 但是内核线程没有用户空间， 它执行的只是内核中的一小段代码（ 通常是一小段函数） ， 所以它没有mm 结构， 也就是NULL。 当某个进程是一个普通用户态进程的时候， PCB 中的 cr3 就是 mm中页表（ pgdir） 的物理地址； 而当它是内核线程的时候， cr3 等于 boot_cr3。 而boot_cr3指向了ucore启动时建立好的饿内核虚拟空间的页目录表首地址。</li><li><code>kstack</code>: 每个进程都有一个内核栈， 并且位于内核地址空间的不同位置。 对于内核线程， 该栈就是运行时的程序使用的栈； 而对于普通进程， 该栈是发生特权级改变的时候使保存被打断的硬件信息用的栈。 Ucore在创建进程时分配了 2 个连续的物理页（ 参见 memlayout.h） 作为内核栈的空间。 这个栈很小， 所以内核中的代码应该尽可能的紧凑， 并且避免在栈上分配大的数据结构， 以免栈溢出， 导致系统崩溃。 kstack记录了分配给该进程/线程的内核栈的位置。 </li></ul><blockquote><p>主要作用有以下几点。</p></blockquote><blockquote><p>首先， 当内核准备从一个进程切换到另一个的时候， 需要根据 kstack 的值正确的设置好 tss （ 可以回顾一下在lab1中讲述的 tss 在中断处理过程中的作用） ， 以便在进程切换以后再发生中断时能够使用正确的栈。</p></blockquote><blockquote><p>其次， 内核栈位于内核地址空间， 并且是不共享的（ 每个进程/线程都拥有自己的内核栈），因此不受到 mm 的管理， 当进程退出的时候， 内核能够根据 kstack 的值快速定位栈的位置并进行回收。它使得每个进程/线程的内核栈在不同的位置， 这样从某种程度上方便调试， 但同时也使得内核对栈溢出变得十分不敏感， 因为一旦发生溢出， 它极可能污染内核中其它的数据使得内核崩溃。 如果能够通过页表， 将所有进程的内核栈映射到固定的地址上去， 能够避免这种问题， 但又会使得进程切换过程中对栈的修改变得相当繁琐。 为了管理系统中所有的进程控制块， ucore维护了如下全局变量（ 位于<code>kern/process/proc.c</code>） ：<code>static struct proc *current</code>; //当前占用CPU， 处于“运行”状态进程控制块指针。 通常这个变量是只读的， 只有在进程切换的时候才进行修改， 并且整个切换和修改过程需要保证操作的原子性， 目前至少需要屏蔽中断， 可以参考 switch_to 的实现。 linux的实现很将进程控制块放在进程内核栈的底部， 这使得任何时候 current 都可以根据内核栈的位置计算出来的， 而不用维护一个全局变量。 这样使得一致性的维护以及多核的实现变得十分的简单和高效。</p></blockquote><ul><li><p><code>static struct proc *initproc</code>:指向第一个用户态进程（ proj10以后）</p></li><li><p><code>static list_entry_t hash_list[HASH_LIST_SIZE]</code> :所有进程控制块的哈希表， 这样proc_struct中的域hash_link将基于pid链接入这个哈希表中。</p></li><li><p><code>list_entry_t proc_list</code>:所有进程控制块的双向线性列表， 这样proc_struct中的域list_link将链接入这个链表中。 </p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175912.png" alt="1591111081468" style="zoom:50%;"></li></ul><h2 id="1-2、-进程的状态转换"><a href="#1-2、-进程的状态转换" class="headerlink" title="1.2、  进程的状态转换"></a>1.2、  进程的状态转换</h2><h2 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h2><ul><li><p>运行态指进程占有处理器运行，处于运行态的进程个数不能大于处理器个数</p></li><li><p>就绪态指进程具备运行条件等待处理器运行</p></li><li><p>等待态指进程由于等待资源、输入输出、信号等而不具备运行条件</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175913.png" alt="屏幕快照 2018-02-24 15.38.45"></p><p>（1）运行态→等待态：出现等待事件，如等待资源、I/O、信号</p><p>（2）等待态→就绪态：等待事件完成，如资源满足、I/O结束、信号完成</p><p>（3）就绪态→运行态：处理器空闲时会选择更高优先权进程抢占</p><p>（4）运行态→就绪态：运行时间片到、有更高优先权进程</p><p>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况，运行资源不足表现为性能低和死锁两种情况。 解决办法为进程挂起：剥夺某些进程的内存及其他资源，调入OS管理的对换区，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175914.png" alt="屏幕快照 2018-02-24 15.43.25" style="zoom:100%;"></li><li><p>一般选择等待态进程进入挂起等待态，也可选择就绪态进程进入挂起就绪态，运行态进程还可以挂起自己进入挂起就绪态</p></li><li><p>等待事件结束后，挂起等待态进入挂起就绪态，一般选择挂起就绪态进程予以恢复</p></li><li><p>挂起态与等待态有着本质区别，等待态占有已申请到的资源处于等待，挂起态没有任何资源</p></li></ul><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><h2 id="练习1：分配并初始化一个进程控制块（需要编码）"><a href="#练习1：分配并初始化一个进程控制块（需要编码）" class="headerlink" title="练习1：分配并初始化一个进程控制块（需要编码）"></a>练习1：分配并初始化一个进程控制块（需要编码）</h2><blockquote><p> 问题1.1：alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。 </p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">static struct proc_struct *alloc_proc(void) {      struct proc_struct *proc = kmalloc(sizeof(struct                                           proc_struct));      if (proc != NULL) {          proc->state = PROC_UNINIT; 表示进程状态，在此函数中应赋值为`PROC_UNINIT`，表示该进程的初始化尚未完成（对进程状态的修改在`do_fork`函数的最后，通过调用`sched.c:wakeup_proc`函数完成）          proc->pid = -1;            进程PID为-1，表示尚未分配，`pid`在`do_fork`函数中通过调用`get_pid`进行分配          proc->runs = 0;            初始化时间片          proc->kstack = 0;          内核堆栈起始地址，此时堆栈尚未分配，初始化置为0；在`do_fork`函数中通过调用`setup_kstack`进行分配          proc->need_resched = 0;    //不需要调度          proc->parent = NULL;       父进程为空，在`do_fork`中初始化为调用`do_fork`的当前进程          proc->mm = NULL;           内存管理，初始化为`NULL`；在`do_fork`中通过调用`copy_mm`进行初始化          memset(&(proc->context), 0, sizeof(struct                  context));          初始化上下文，在`do_fork`中通过调用`copy_thread`函数进行初始化          proc->tf = NULL;           中断帧指针为空          proc->cr3 = boot_cr3;      所有内核进程的内核虚地址空是相同的，内核进程共用一个映射内核空间的页表          proc->flags = 0;           当前进程属性置为0          memset(proc->name, 0, PROC_NAME_LEN);   进程的名称，初始化清零    }    return proc;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><blockquote><p> 问题1.2：请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？</p></blockquote><ul><li><p><code>context</code>：进程的上下文，用于进程切换（参见<code>switch.S</code>）。在 uCore中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用<code>context</code>保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用<code>context</code>进行上下文切换的函数是<code>kern/process/switch.S:switch_to</code>，对于<code>switch_to</code>函数的主要工作是把被切换的进程的各个通用寄存器（eip、esp、ebx、ecx、edx、esi、edi、ebp，但不包括段寄存器，因为对于内核进程来说他们共享相同的段地址）保存到进程的<code>context</code>结构中，然后加载即将开始运行的进程的<code>context</code>结构中保存的通用寄存器。</p><pre class="line-numbers language-c++"><code class="language-c++">struct context {    uint32_t eip;    uint32_t esp;    uint32_t ebx;    uint32_t ecx;    uint32_t edx;    uint32_t esi;    uint32_t edi;    uint32_t ebp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>trapframe *tf</code>：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。当内核需要跳回用户空间时，需要调整中断帧以恢复让进程继续执行的各寄存器值。除此之外，UCore内核允许嵌套中断。因此为了保证嵌套中断发生时<code>tf</code>总是能够指向当前的<code>trapframe</code>，uCore 在内核栈上维护了<code>tf</code>的链</p></li></ul><p>定义在<code>kern/trap/trap.h</code>中：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> trapframe <span class="token punctuation">{</span>    <span class="token keyword">struct</span> pushregs tf_regs<span class="token punctuation">;</span>    uint16_t tf_gs<span class="token punctuation">;</span>    uint16_t tf_padding0<span class="token punctuation">;</span>    uint16_t tf_fs<span class="token punctuation">;</span>    uint16_t tf_padding1<span class="token punctuation">;</span>    uint16_t tf_es<span class="token punctuation">;</span>    uint16_t tf_padding2<span class="token punctuation">;</span>    uint16_t tf_ds<span class="token punctuation">;</span>    uint16_t tf_padding3<span class="token punctuation">;</span>    uint32_t tf_trapno<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* below here defined by x86 hardware */</span>    uint32_t tf_err<span class="token punctuation">;</span>    uintptr_t tf_eip<span class="token punctuation">;</span>    uint16_t tf_cs<span class="token punctuation">;</span>    uint16_t tf_padding4<span class="token punctuation">;</span>    uint32_t tf_eflags<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* below here only when crossing rings, such as from user to kernel */</span>    uintptr_t tf_esp<span class="token punctuation">;</span>    uint16_t tf_ss<span class="token punctuation">;</span>    uint16_t tf_padding5<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token function">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习2：为新创建的内核线程分配资源（需要编码）"><a href="#练习2：为新创建的内核线程分配资源（需要编码）" class="headerlink" title="练习2：为新创建的内核线程分配资源（需要编码）"></a>练习2：为新创建的内核线程分配资源（需要编码）</h2><p>创建一个内核线程需要分配和设置好很多资源。kernel_thread函数通过调用do_fork函数完成具体内核线程的创建工作。do_kernel函数会调用<code>alloc_proc</code>函数来分配并初始化一个进程控制块，也就是我们在第一个练习中所完成的函数，但是对于<code>alloc_proc</code>只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。</p><p>一般通过<code>do_fork</code>实际创建新的内核线程。do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。</p><p>do_fork函数在<code>kern/process/proc.c</code>中,大致执行步骤包括：<br>1． 分配并初始化进程控制块（ alloc_proc函数）<br>2． 分配并初始化内核栈（ setup_stack函数）<br>3． 根据clone_flag标志复制或共享进程内存管理结构 </p><p>  如果上述前3步执行没有成功， 则需要做对应的出错处理， 把相关已经占有的内存释放掉。   </p><p>4． 设置进程在内核（ 将来也包括用户态） 正常运行和调度所需的中断帧和执行上下文（ copy_thread函数） ；<br>5． 把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中；<br>6． 自此， 进程已经准备好执行了， 把进程状态设置为“就绪”态。  </p><pre class="line-numbers language-c++"><code class="language-c++">intdo_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {    int ret = -E_NO_FREE_PROC; //尝试为进程分配内存    struct proc_struct *proc; //定义新进程    if (nr_process >= MAX_PROCESS) { //分配进程数大于4096,返回        goto fork_out;    }    ret = -E_NO_MEM;  //因内存不足而分配失败    if ((proc = alloc_proc()) == NULL) { //分配内存失败            goto fork_out;         }    proc->parent = current; //设置父进程名字    if (setup_kstack(proc) != 0) {//分配内核栈        goto bad_fork_cleanup_proc;     }    if (copy_mm(clone_flags, proc) != 0) { //复制父进程内存信息        goto bad_fork_cleanup_kstack;     }    copy_thread(proc, stack, tf); //复制中断帧和上下文信息    bool intr_flag;     local_intr_save(intr_flag);  //屏蔽中断，intr_flag置为1    {        proc->pid = get_pid(); //获取当前进程PID        hash_proc(proc);  //建立hash映射        list_add(&proc_list,&(proc->list_link));//加入进程链表        nr_process ++;  //进程数加一    }    local_intr_restore(intr_flag); //恢复中断    wakeup_proc(proc); //唤醒新进程    ret = proc->pid; //返回当前进程的PIDfork_out:  //已分配进程数大于4096    return ret;bad_fork_cleanup_kstack: //分配内核栈失败    put_kstack(proc);bad_fork_cleanup_proc:     kfree(proc);    goto fork_out;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>  问题2.1：请说明ucore是否做到给每个新fork的线程一个唯一的id？ 请说明你的分析和理由。  </p></blockquote><p>是。 在分配PID和将进程插入队列的过程中进行了关中断处理，保证原子操作。 </p><p> PID的唯一性是通过关中断和<code>get_pid</code>函数保证的，该函数通过遍历进程链表，查看当前的全部进程，在不发生中断的情况下，可以保证新分配的PID与之前的PID是不冲突的。 </p><pre class="line-numbers language-c++"><code class="language-c++">// get_pid - alloc a unique pid for processstatic intget_pid(void) {    static_assert(MAX_PID > MAX_PROCESS);    struct proc_struct *proc;    list_entry_t *list = &proc_list, *le;    static int next_safe = MAX_PID, last_pid = MAX_PID;    if (++ last_pid >= MAX_PID) {        last_pid = 1;        goto inside;    }    if (last_pid >= next_safe) {    inside:        next_safe = MAX_PID;    repeat:        le = list;        while ((le = list_next(le)) != list) {            proc = le2proc(le, list_link);            if (proc->pid == last_pid) {                if (++ last_pid >= next_safe) {                    if (last_pid >= MAX_PID) {                        last_pid = 1;                    }                    next_safe = MAX_PID;                    goto repeat;                }            }            else if (proc->pid > last_pid && next_safe > proc->pid) {                next_safe = proc->pid;            }        }    }    return last_pid;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。（无编码工作）"><a href="#练习3：阅读代码，理解-proc-run-函数和它调用的函数如何完成进程切换的。（无编码工作）" class="headerlink" title="练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）"></a>练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。（无编码工作）</h2><blockquote><p> 请在实验报告中简要说明你对proc_run函数的分析。 </p></blockquote><p> 首先分析schedule函数的源码： </p><pre class="line-numbers language-c++"><code class="language-c++">voidschedule(void) {    bool intr_flag; //定义中断变量    list_entry_t *le, *last; //当前list，下一list    struct proc_struct *next = NULL; //下一进程    local_intr_save(intr_flag); //中断禁止函数    {        current->need_resched = 0; //设置当前进程不需要调度      //last是否是idle进程(第一个创建的进程),如果是，则从表头开始搜索      //否则获取下一链表        last = (current == idleproc) ? &proc_list : &(current->list_link);        le = last;         do { //一直循环，直到找到可以调度的进程            if ((le = list_next(le)) != &proc_list) {                next = le2proc(le, list_link);//获取下一进程                if (next->state == PROC_RUNNABLE) {                    break; //找到一个可以调度的进程，break                }            }        } while (le != last); //循环查找整个链表        if (next == NULL || next->state != PROC_RUNNABLE) {            next = idleproc; //未找到可以调度的进程        }        next->runs ++; //运行次数加一        if (next != current) {            proc_run(next); //运行新进程,调用proc_run函数        }    }    local_intr_restore(intr_flag); //允许中断}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到ucore实现的是FIFO调度算法：</p><p>1 调度开始时，先屏蔽中断。</p><p>2 在进程链表中，查找第一个可以被调度的程序</p><p>3 运行新进程，允许中断</p><p>然后再看到proc_run函数方法：</p><pre class="line-numbers language-c++"><code class="language-c++">voidproc_run(struct proc_struct *proc) {    if (proc != current) {        bool intr_flag;        struct proc_struct *prev = current, *next = proc;        local_intr_save(intr_flag);        {            current = proc;            load_esp0(next->kstack + KSTACKSIZE);            lcr3(next->cr3);            switch_to(&(prev->context), &(next->context));        }        local_intr_restore(intr_flag);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码的执行过程如下：</p><ol><li><p><code>local_intr_save(intr_flag)</code>关闭中断，保证原子操作</p></li><li><p>调用<code>load_esp0</code>函数，设置任务状态段<code>ts</code>中特权态0下的栈顶指针<code>esp0</code>为要切换到的内核线程的内核栈的栈顶，即<code>next-&gt;kstack + KSTACKSIZE</code>（建立指针的目的是，进行特权态切换时能够正确定位处于特权态0时进程的内核栈的栈顶）</p></li><li><p>设置CR3寄存器的值为要切换到的内核线程的页目录表起始地址，这实际上是完成进程间的页表切换，不过由于所有内核进程的内核虚地址空是相同的，内核进程共用一个映射内核空间的页表</p></li><li><p>由 <code>switch_to</code>函数完成具体的两个线程的执行现场切换，先保存当前寄存器的值，然后再将下一进程的上下文信息保存到寄存器中 。当<code>switch_to</code>函数执行完<code>ret</code>指令后，就切换到 <code>initproc</code>执行了</p><pre class="line-numbers language-c++"><code class="language-c++">.text.globl switch_toswitch_to:                      # switch_to(from, to)    # save from's registers    movl 4(%esp), %eax          # eax points to from    popl 0(%eax)                # save eip !popl    movl %esp, 4(%eax)          # save esp::context of from    movl %ebx, 8(%eax)          # save ebx::context of from    movl %ecx, 12(%eax)         # save ecx::context of from    movl %edx, 16(%eax)         # save edx::context of from    movl %esi, 20(%eax)         # save esi::context of from    movl %edi, 24(%eax)         # save edi::context of from    movl %ebp, 28(%eax)         # save ebp::context of from    # restore to's registers    movl 4(%esp), %eax          # not 8(%esp): popped return address already                                # eax now points to to    movl 28(%eax), %ebp         # restore ebp::context of to    movl 24(%eax), %edi         # restore edi::context of to    movl 20(%eax), %esi         # restore esi::context of to    movl 16(%eax), %edx         # restore edx::context of to    movl 12(%eax), %ecx         # restore ecx::context of to    movl 8(%eax), %ebx          # restore ebx::context of to    movl 4(%eax), %esp          # restore esp::context of to    pushl 0(%eax)               # push eip    ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>在切换现场时，倒数第二条汇编指令<code>pushl 0(%eax)</code>其实把<code>context</code>中保存的下一个进程要执行的指令地址<code>context.eip</code>放到了堆栈顶，这样接下来执行最后一条指令<code>ret</code>时，会把栈顶的内容赋值给EIP寄存器，这样就切换到下一个进程执行了。</p><blockquote><p> 问题3.1：在本实验的执行过程中，创建且运行了几个内核线程？ </p></blockquote><p><code>proc_init</code>函数是由<code>kern_init</code>函数调用的。在<code>kern_init</code>完成其余初始化之后，它调用<code>cpu_idle</code>函数，使得当前的<code>idle_proc</code>进程让出控制权，交给<code>initproc</code>线程，进行上下文的切换；执行完之后，回到<code>kernel_thread_entry</code>，退出。</p><p>在本实验的执行过程中，一共只创建了两个内核线程（<code>idleproc</code>和<code>initproc</code>）。</p><p>其中<code>idleproc</code>第一个内核进程，完成内核中各个子系统的初始化， 然后调度执行其他进程或线程</p><p>而<code>initproc</code>是用于完成实验的功能而调度的内核进程 ，在屏幕上输出字符串。 </p><blockquote><p>问题3.2：语句local_intr_save(intr_flag);….local_intr_restore(intr_flag);在这里有何作用?请说明理由</p></blockquote><p>用于关中断和开中断，使得进程在进行上下文切换的过程中不被中断打断。</p>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab02</title>
      <link href="/2020/05/16/ucore-lab02/"/>
      <url>/2020/05/16/ucore-lab02/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab02"><a href="#Ucore-Lab02" class="headerlink" title="Ucore Lab02"></a>Ucore Lab02</h1><h1 id="一、操作系统原理"><a href="#一、操作系统原理" class="headerlink" title="一、操作系统原理"></a>一、操作系统原理</h1><h2 id="1-1、分页内存管理"><a href="#1-1、分页内存管理" class="headerlink" title="1.1、分页内存管理"></a>1.1、分页内存管理</h2><pre><code>      在分页内存管理中， 一方面把实际物理内存（ 也称主存） 划分为许多个固定大小的内存块， 称为物理页面， 或者是页框（ page frame） ； 另一方面又把CPU（ 包括程序员） 看到的虚拟地址空间也划分为大小相同的块， 称为虚拟页面， 或者简称为页面、 页（ page） 。 页面的大小要求是2的整数次幂，一般在256个字节到4M字节之间。 在本书中， 页面的大小设定为4KB。 在32位的86x86中， 虚拟地址空间是4GB， 物理地址空间也也是4GB， 因此在理论上程序可访问到1M个虚拟页面和1M个物理页面。软件的每一物理页面都可以放置在主存中的任何地方， 分页系统（ 需要CPU等硬件系统提供相应的分页机制硬件支持， 详见下一节） 提供了程序中使用的虚地址和主存中的物理地址之间的动态映射。 这样当程序访问一个虚拟地址时， 支持分页机制的相关硬件自动把CPU访问的虚拟地址虚拟地址拆分为页号（ 可能有多级页号） 和页内偏移量， 再把页号映射为页帧号， 最后加上页内偏移组成一个物理地址， 这样最终完成对这个地址的读/写/执行等操作       假设程序在运行时要去读地址0x100的内容到寄存器1（ 用REG1表示） 中， 执行如下的指令：` mov 0x100, REG1`     虚拟地址0x100被发送给CPU内部的内存管理单元（ MMU） ， 然后MMU通过支持分页机制的相关硬件逻辑就会把这个虚拟地址是位于第0个虚拟页面当中（ 设页大小为4KB） ， 页内偏移是0x100； 而操作系统的分页管理子系统已经设置好第0个虚拟页面对应的是第2个物理页帧， 物理页帧的起始地址是0x2000， 然后再加上页内的偏移地址0x100， 所以最后得到的物理地址就是0x2100。 然后MMU就会把这个真正的物理地址发送到计算机系统中的地址总线上， 从而可正确访问相应的物理内存单元。如果操作系统的分页管理子系统没有设置第0个虚拟页面对应的物理页帧， 则表示第0个虚拟页面当前没有对应的物理页帧， 这会导致CPU产生一个缺页异常， 由操作系统的缺页处理服务例程来选择如何处理。 如果缺页处理服务例程认为这是一次非法访问， 它将报错， 终止软件运行； 如果它认为是一次合理的访问， 则它会采用分配物理页等手段建立正确的页映射， 使得能够重新正确执行产生异常的访存指令  </code></pre><h2 id="1-2、段页式内存管理策略寻址过程"><a href="#1-2、段页式内存管理策略寻址过程" class="headerlink" title="1.2、段页式内存管理策略寻址过程"></a>1.2、段页式内存管理策略寻址过程</h2><h2 id="x86-内存管理单元-MMU"><a href="#x86-内存管理单元-MMU" class="headerlink" title="x86 内存管理单元 MMU"></a>x86 内存管理单元 MMU</h2><h3 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h3><p>首先通过段选择子作为索引 在 GDT 全局描述符表中找到 段描述符 若没启动页机制的话 那么现在就找到 线性地址</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175120.png" alt="img" style="zoom:50%;"><p>GDT 存在于内存当中 因为它所占空间比较大 但是由于内存比较慢 每次去访问 段表的时候 耗费比较大 因此 硬件会将 GDT 中的描述信息(Base Address, Limit…) 放在 CPU 来加快段的映射过程</p><h3 id="页机制"><a href="#页机制" class="headerlink" title="页机制"></a>页机制</h3><ol><li>线性地址 的 高十位 + cr3 中的 PDE 页目标表的地址 找到 PTE 页表的 物理地址</li><li>PTE 页表物理地址+ 线性地址中间 10位 找到 物理页基址</li><li>物理页基址 加上 线性地址的 低 12位 找到物理地址</li></ol><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175121.png" alt="img" style="zoom:50%;"><h3 id="如何开启页机制"><a href="#如何开启页机制" class="headerlink" title="如何开启页机制"></a>如何开启页机制</h3><ol><li>准备好页目录表和页表</li><li>页目录表物理地址 写入 cr3 寄存器</li><li>cr0 最高位 PG位 置 1</li></ol><h3 id="段机制和页机制都能作为映射机制-应该如何选择"><a href="#段机制和页机制都能作为映射机制-应该如何选择" class="headerlink" title="段机制和页机制都能作为映射机制 应该如何选择?"></a>段机制和页机制都能作为映射机制 应该如何选择?</h3><p>选择页机制有助于硬件机制对其进行有效的处理</p><p>使用段机制的安全保护手段 来保护系统的安全 但是弱化了 段机制的映射 使用页机制的映射</p><p>段机制和页机制结合成段页式的存储管理 从而 既能便于程序的共享和保护 又能高效率利用存储空间</p><h3 id="线性地址-虚拟地址-逻辑地址-物理地址-有效地址-区别"><a href="#线性地址-虚拟地址-逻辑地址-物理地址-有效地址-区别" class="headerlink" title="线性地址 虚拟地址 逻辑地址 物理地址 有效地址 区别"></a>线性地址 虚拟地址 逻辑地址 物理地址 有效地址 区别</h3><ul><li><p>保护模式 段基址+段偏移 = 线性地址 若不开分页 == 物理地址</p></li><li><p>实模式/保护模式 段偏移 = 有效地址 也称 逻辑地址</p></li><li><p>开启分页后 线性地址 == 虚拟地址</p></li></ul><h2 id="1-3、内存分配算法"><a href="#1-3、内存分配算法" class="headerlink" title="1.3、内存分配算法"></a>1.3、内存分配算法</h2><h3 id="首次适应算法"><a href="#首次适应算法" class="headerlink" title="首次适应算法"></a>首次适应算法</h3><p>找第一个满足大小的空闲分区</p><p>该算法从空闲分区链首开始查找，直至找到一个能满足其大小要求的空闲分区为止。然后再按 照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中</p><p>优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲 区。显然为以后到达的大作业分配大的内存空间创造了条件<br>缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销</p><h3 id="最坏适应算法"><a href="#最坏适应算法" class="headerlink" title="最坏适应算法"></a>最坏适应算法</h3><p>找最大的满足大小的空闲分区</p><p>该算法按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲区中分配（不能 满足需要则不分配）。很显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但它也有很强的直观吸引力：在大空闲区中放入程序后，剩下的空闲区常常也很大，于是还能装下一个较大的新程序。最坏适应算法与最佳适应算法的排序正好相反，它的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲 区开始查寻。该算法克服了最佳适应算法留下的许多小的碎片的不足，但保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法一样复杂。</p><p>优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。<br>缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。</p><h3 id="最佳适应算法"><a href="#最佳适应算法" class="headerlink" title="最佳适应算法"></a>最佳适应算法</h3><p>找最小的满足大小的空闲分区</p><p>该算法总是把既能满足要求，又是最小的空闲分区分配给作业。为了加速查找，该算法要求将 所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足要求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。</p><p>优点：每次分配给文件的都是最合适该文件大小的分区。<br>缺点：内存中留下许多难以利用的小的空闲区。</p><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><h2 id="练习0：-填写已有实验"><a href="#练习0：-填写已有实验" class="headerlink" title="练习0： 填写已有实验"></a>练习0： 填写已有实验</h2><p>本实验依赖实验1，请把你做的实验1的代码填入本实验中代码中有“LAB1”的注释相应部分。 提示： 可采用diff和patch工具进行半自动的合并（ merge） ， 也可用一些图形化的比较/merge工具来手动合并， 比如meld， eclipse中的diff/merge工具，understand中的diff/merge工具等。**  </p><p> <a href="http://wowubuntu.com/meld.html" target="_blank" rel="noopener">Meld</a> 是GNOME 项目中的一款可视化的文件及目录对比（diff) / 合并 (merge) 工具，通过它你可以对两个或三个文件/目录进行对比，并以图形化的方式显示出它们的不同之处, </p><p>打开 meld 从主界面就能看到应用的分工主要分为三块</p><ul><li>文件内容的比较</li><li>文件夹内容的比较</li><li>版本控制的比较</li></ul><p>前两个比较工具都可以选择两个或者三个输入源，后面的版本控制只需要一个版本控制的路径。meld 会自动对选中的内容进行比较,在练习0中就可以通过图形化的界面很快速地实现练习0跟练习1之间代码的合并</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175122.png" alt="1588005050936" style="zoom:30%;"> <h2 id="练习1：实现-first-fit-连续物理内存分配算法"><a href="#练习1：实现-first-fit-连续物理内存分配算法" class="headerlink" title="练习1：实现 first-fit 连续物理内存分配算法"></a>练习1：实现 first-fit 连续物理内存分配算法</h2><blockquote><p>修改<code>default_pmm.c</code>中<code>default\_alloc\_pages</code>函数和<code>default\_free\_pages</code>函数，实现<code>first\_fit</code>内存分配算法。 </p></blockquote><p>查看<code>default_init_memmap()</code></p><p><code>le2page(le, member)</code>：通过<code>list entry</code>的地址减去<code>list entry</code>在内存中的偏移量得到Page这一个页的首地址</p><pre class="line-numbers language-c++"><code class="language-c++">// convert list entry to page#define le2page(le, member)                 \    to_struct((le), struct Page, member)#define to_struct(ptr, type, member)                               \    ((type *)((char *)(ptr) - offsetof(type, member)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中用到的结构体定义</p><pre class="line-numbers language-c++"><code class="language-c++">struct list_entry {    struct list_entry *prev, *next; };typedef struct list_entry list_entry_t; //重命名typedef struct {    list_entry_t free_list; //链表头部            unsigned int nr_free;   //空闲块的个数    } free_area_t; //链表头部结构struct Page {    int ref;       //映射此物理页的虚拟页的个数           uint32_t flags; //物理页属性        unsigned int property;  //连续空页有多少(只在地址最低页有值)    list_entry_t page_link; // 双向链接前驱与后继空闲Page结构的page_link};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现中所用到的数据结构为双向链表，在一块连续的页空间内，使用地址最小的一页（Head Page）记录这块内存地址的大小，并通过成员变量page_link来维护链表结构。</p><pre class="line-numbers language-c++"><code class="language-c++">// 初始化空闲页块链表static void default_init(void) {    list_init(&free_list);    nr_free = 0; // 空闲页块一开始是0个}// 初始化n个空闲页块static void default_init_memmap(struct Page *base, size_t n) {    assert(n > 0);    struct Page *p = base;    for (; p != base + n; p ++) {        assert(PageReserved(p)); // 看看这个页是不是被内核保留的        p->flags = p->property = 0;        set_page_ref(p, 0);    }    base->property = n; // 头一个空闲页块 要设置数量    //#define SetPageProperty(page)       set_bit(PG_property, &((page)->flags))    说明这时候base这个内存首地址是这块空闲内存地址中的首部地址    SetPageProperty(base);    nr_free += n;    // 初始化玩每个空闲页后 将其要插入到链表每次都插入到节点前面 因为是按地址排序    list_add_before(&free_list, &(base->page_link));}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>default_alloc_pages</code>分配n个页面大小的内存空间</p><h3 id="分配内存主要分为以下几个步骤："><a href="#分配内存主要分为以下几个步骤：" class="headerlink" title="分配内存主要分为以下几个步骤："></a>分配内存主要分为以下几个步骤：</h3><ol><li>判断空闲地址空间是否大于所需空间</li><li>从free_list开始，遍历链表，直到找到第一块不小于所需空间大小的内存块</li><li>分配连续的n页，修改标志位</li><li>从链表中删除此内存块，如果有剩余的小的内存块，重新插入链表</li></ol><pre class="line-numbers language-c++"><code class="language-c++">// 分配n个页块static struct Page * default_alloc_pages(size_t n) {    assert(n > 0);    if (n > nr_free) {        return NULL;    }    struct Page *page = NULL;    list_entry_t *le = &free_list;    // 查找 n 个或以上 空闲页块 若找到 则判断是否大过 n 则将其拆分 并将拆分后的剩下的空闲页块加回到链表中    while ((le = list_next(le)) != &free_list) {        // 此处 le2page 就是将 le 的地址 - page_link 在 Page 的偏移 从而找到 Page 的地址        struct Page *p = le2page(le, page_link);        if (p->property >= n) {            page = p;            break;        }    }    if (page != NULL) {        if (page->property > n) {            struct Page *p = page + n;            p->property = page->property - n;            SetPageProperty(p);            // 将多出来的插入到被分配掉的页块 后面            list_add(&(page->page_link), &(p->page_link));        }        // 最后在空闲页链表中删除掉原来的空闲页        list_del(&(page->page_link));        nr_free -= n;        ClearPageProperty(page);    }    return page;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="释放内存的函数主要分为以下步骤："><a href="#释放内存的函数主要分为以下步骤：" class="headerlink" title="释放内存的函数主要分为以下步骤："></a>释放内存的函数主要分为以下步骤：</h3><ol><li><p>修改释放页的标志位</p></li><li><p>判断此块空余空间能否与前后空余空间合并，如果可以将其合并</p></li></ol><pre class="line-numbers language-c++"><code class="language-c++">   // 释放掉 n 个 页块   static void default_free_pages(struct Page *base, size_t n) {       assert(n > 0);       struct Page *p = base;       for (; p != base + n; p ++) {           assert(!PageReserved(p) && !PageProperty(p));           p->flags = 0;           set_page_ref(p, 0);       }       base->property = n;       SetPageProperty(base);       list_entry_t *le = list_next(&free_list);       // 合并到合适的页块中       while (le != &free_list) {           p = le2page(le, page_link);           le = list_next(le);           if (base + base->property == p) {               base->property += p->property;               ClearPageProperty(p);               list_del(&(p->page_link));           }           else if (p + p->property == base) {               p->property += base->property;               ClearPageProperty(base);               base = p;               list_del(&(p->page_link));           }       }       nr_free += n;       list_add(&free_list, &(base->page_link));   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">default_free_pages</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Page <span class="token operator">*</span>base<span class="token punctuation">,</span> size_t n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> Page <span class="token operator">*</span>p <span class="token operator">=</span> base<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> base <span class="token operator">+</span> n<span class="token punctuation">;</span> p <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">PageReserved</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">PageProperty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token operator">-></span>flags <span class="token operator">=</span> p<span class="token operator">-></span>property <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">set_page_ref</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    base<span class="token operator">-></span>property <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token function">SetPageProperty</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>    list_entry_t <span class="token operator">*</span>le <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>free_list<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>le <span class="token operator">!=</span> <span class="token operator">&amp;</span>free_list<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token function">le2page</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> page_link<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>p <span class="token operator">></span> base<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>        le <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span>le<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">list_add_before</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>base<span class="token operator">-></span>page_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">le2page</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> page_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>le <span class="token operator">!=</span> <span class="token operator">&amp;</span>free_list <span class="token operator">&amp;&amp;</span> base <span class="token operator">+</span> base<span class="token operator">-></span>property <span class="token operator">==</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        base<span class="token operator">-></span>property <span class="token operator">+</span><span class="token operator">=</span> p<span class="token operator">-></span>property<span class="token punctuation">;</span>        <span class="token function">ClearPageProperty</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>page_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    le <span class="token operator">=</span> <span class="token function">list_prev</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>base<span class="token operator">-></span>page_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">le2page</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> page_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>le <span class="token operator">!=</span> <span class="token operator">&amp;</span>free_list <span class="token operator">&amp;&amp;</span> p <span class="token operator">+</span> p<span class="token operator">-></span>property <span class="token operator">==</span> base<span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>property <span class="token operator">+</span><span class="token operator">=</span> base<span class="token operator">-></span>property<span class="token punctuation">;</span>        <span class="token function">ClearPageProperty</span><span class="token punctuation">(</span>base<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">list_del</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>base<span class="token operator">-></span>page_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    nr_free <span class="token operator">+</span><span class="token operator">=</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题1.1：你的first fit算法是否有进一步的改进空间</p></blockquote><p>有，在我的实现中，目前使用的是链表的方式维护空闲内存将一块连续的物理空间的第一页插入链表，并记录这块地址空间的大小，每次查询第一块符合条件的空闲内存块时，最坏情况需要找遍整个链表，这样的话时间复杂度是O（N），N表示当前的链表大小，考虑针对时间效率的优化方式如下：</p><p>其中优化的方式包括：</p><ul><li>采用平衡二叉树结构来取代简单的链表结构来维护空闲块，其中按照中序遍历得到的空闲块序列的物理地址恰好按照从小到大排序 </li><li>每个二叉树节点上动态维护（可分配内存的大小，目前的内存地址）这样一个二元组</li><li>在每次进行查询的时候，不妨从根节点开始，查询左子树的最大空闲块是否符合要求，如果是的话进入左子树进行进一步查询，否则进入右子树；（二分查找）</li><li>按照上述方法，最终可以查找到物理地址最小的能够满足条件的空闲地址块，进行删除以及新的分裂出来的空闲块的插入等操作；</li><li>按照上述方法的话，每次查询符合条件的第一块物理空闲块的时间复杂度为O(log N)，对比原先的O（N）有了较大的改进；</li></ul><h2 id="练习2：实现寻找虚拟地址对应的页表项"><a href="#练习2：实现寻找虚拟地址对应的页表项" class="headerlink" title="练习2：实现寻找虚拟地址对应的页表项"></a>练习2：实现寻找虚拟地址对应的页表项</h2><p>修改pmm.c中的get_pte函数，主要实现逻辑是：</p><ol><li><p>根据虚地址的高十位查询页目录，找到页表项的pdep</p></li><li><p>检查该页是否在内存中，如果不在，创建该页，并更新相关信息</p></li><li><p>根据虚拟地址的中间十位，找到虚拟地址对应的页表项</p></li></ol><p>几个函数定义： <code>PDX(la)</code>：线性虚拟地址的高十位保存着页目录对应的索引值，指向页表项所在的地址</p><pre class="line-numbers language-c++"><code class="language-c++">// page directory index#define PDX(la) ((((uintptr_t)(la)) >> PDXSHIFT) & 0x3FF)#define PDXSHIFT        22                      // offset of PDX in a linear address<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">static inline uintptr_tpage2pa(struct Page *page) {    return page2ppn(page) << PGSHIFT;}static inline ppn_tpage2ppn(struct Page *page) {    return page - pages;}#define PGSHIFT         12                      // log2(PGSIZE)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>PTE_ADDR(pte)</code>:保留页目录项和页表项的高20位存储的相应的物理页帧号，清空低12位存储标志位</p><pre class="line-numbers language-c++"><code class="language-c++">// address in page table or page directory entry#define PTE_ADDR(pte)   ((uintptr_t)(pte) & ~0xFFF)#define PDE_ADDR(pde)   PTE_ADDR(pde)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="函数的具体实现与对应的注释解读："><a href="#函数的具体实现与对应的注释解读：" class="headerlink" title="函数的具体实现与对应的注释解读："></a>函数的具体实现与对应的注释解读：</h3><pre class="line-numbers language-c"><code class="language-c">pde_t <span class="token operator">*</span>pdep <span class="token operator">=</span> <span class="token operator">&amp;</span>pgdir<span class="token punctuation">[</span><span class="token function">PDX</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//校验该页表项是否存在</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">*</span>pdep <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> Page <span class="token operator">*</span>page<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//如果传入的参数是不允许创建，或者当分配新的物理页时候失败，就返回一个空值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>create <span class="token operator">||</span> <span class="token punctuation">(</span>page <span class="token operator">=</span> <span class="token function">alloc_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//映射此物理页的虚拟页的个数设置为1    </span>    <span class="token function">set_page_ref</span><span class="token punctuation">(</span>page<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    页目录项内容 <span class="token operator">=</span> <span class="token punctuation">(</span>页表起始物理地址 <span class="token operator">&amp;</span> <span class="token operator">~</span> <span class="token number">0x0FFF</span><span class="token punctuation">)</span> <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_W <span class="token operator">|</span> PTE_P，意思就是保留页目录项的前<span class="token number">20</span>位，而把后<span class="token number">12</span>位置<span class="token number">0</span>，后<span class="token number">12</span>位保存的是页目录项的标志位    uintptr_t pa <span class="token operator">=</span> <span class="token function">page2pa</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清空这个虚拟地址</span>    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token function">KADDR</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//给该物理页后12位保存的页目录项的标志位赋值，赋予用户权限、可写权限，并置存在位为1</span>      PTE_U： 位<span class="token number">3</span>， 表示用户态的软件可以读取对应地址的物理内存页内容    PTE_W： 位<span class="token number">2</span>， 表示物理内存页内容可写    PTE_P： 位<span class="token number">1</span>， 表示物理内存页存在    <span class="token operator">*</span>pdep <span class="token operator">=</span> pa <span class="token operator">|</span> PTE_U <span class="token operator">|</span> PTE_W <span class="token operator">|</span> PTE_P<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//KADDR - takes a physical address and returns the corresponding kernel virtual</span><span class="token comment" spellcheck="true">//&amp;((pte_t *)KADDR(PDE_ADDR(*pdep)))获得page table entry的基地址，然后通过[PTX(la)]获得对应偏移量的值,PTX(la)获得线性逻辑地址的中间10位</span><span class="token function">PDE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pdep<span class="token punctuation">)</span><span class="token punctuation">:</span>保留页目录项和页表项的高<span class="token number">20</span>位存储的相应的物理页帧号，清空低<span class="token number">12</span>位存储标志位<span class="token punctuation">,</span>然后通过KADDR获得内核虚拟地址，进行一个强制的类型转换，转换为pte_t <span class="token operator">*</span>对象，即页表项的首地址，再通过数组索引寻找到实际的页表项<span class="token keyword">return</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte_t <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">KADDR</span><span class="token punctuation">(</span><span class="token function">PDE_ADDR</span><span class="token punctuation">(</span><span class="token operator">*</span>pdep<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token function">PTX</span><span class="token punctuation">(</span>la<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题2.1：请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p></blockquote><pre><code>页目录项内容 = (页表起始物理地址 &amp; ~ 0x0FFF) | PTE_U | PTE_W | PTE_P页表项内容 = (pa &amp; ~0x0FFF) | PTE_P | PTE_W</code></pre><p>页目录表项和页表项的高20位为物理页表地址/物理页地址 ， 前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）； </p><p>之所以只用到 20 位 是因为页是以 4K 为单位 地址都是 4K的倍数，所以对于后面的12位来说他们都为 0，所以 可以将这多余的 12 位用作属性位存储标志位。标志位的定义为：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> PTE_P           0x001                   </span><span class="token comment" spellcheck="true">// Present  是否存在</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_W           0x002                   </span><span class="token comment" spellcheck="true">// Writeable    是否可写</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_U           0x004                   </span><span class="token comment" spellcheck="true">// User    用户是否有权限</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_PWT         0x008                   </span><span class="token comment" spellcheck="true">// Write-Through</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_PCD         0x010                   </span><span class="token comment" spellcheck="true">// Cache-Disable 是否可被TLB缓存</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_A           0x020                   </span><span class="token comment" spellcheck="true">// Accessed    </span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_D           0x040                   </span><span class="token comment" spellcheck="true">// Dirty 是否是脏页</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_PS          0x080                   </span><span class="token comment" spellcheck="true">// Page Size    页面大小</span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_MBZ         0x180                   </span><span class="token comment" spellcheck="true">// Bits must be zero    </span><span class="token macro property">#<span class="token directive keyword">define</span> PTE_AVAIL       0xE00                   </span><span class="token comment" spellcheck="true">// Available for software use</span>                                                <span class="token comment" spellcheck="true">// The PTE_AVAIL bits aren't used by the kernel or interpreted by the</span>                                                <span class="token comment" spellcheck="true">// hardware, so user processes are allowed to set them arbitrarily.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>G Global 全局位 表示是否将虚拟地址与物理地址的转换结果缓存到 TLB 中</li><li>D Dirty 脏页位 当 CPU 对这个页进行写操作时 会置 1</li><li>PAT Page Attribute Table 页属性表位 置 0</li><li>A Accessed 访问位 若为 1 则 说明 CPU 访问过了 CPU 会定时清 0 记录被置 1 的频率 当内存不足时 会将 使用频率较低的页面换出到外存 同时将 P位 置 0 下次访问 该页时 会引起 Pagefault 异常 中断处理程序再将此页换上</li><li>PCD Page-level Cache Disable 页级高速缓存位 置 0 即可 读的时候 高速缓存是否有效 若有效则直接从高速缓存中读出 若无效的话 则必须实实在在的从 I/O 端口去读数据</li><li>PWT Page-level Write-Through 页级通写位 控制是先写到高速缓存里再慢慢回写到内存里 还是 直接慢慢写到内存里</li><li>US User/Supervisor 普通用户/超级用户位</li><li>RW Read/Write 读写位</li><li>P Present 存在位 (虚拟页式存储的关键位 若为 0 则发起缺页异常)</li></ul><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175123.png" alt="img" style="zoom:50%;"><p>可以发现无论是PTE还是TDE，都具有着一些保留的位供操作系统使用，也就是说ucore可以利用这些位来完成一些其他的内存管理相关的算法，比如可以在这些位里保存最近一段时间内该页的被访问的次数（仅能表示0-7次），用于辅助近似地实现虚拟内存管理中的换出策略的LRU之类的算法；也就是说这些保留位有利于OS进行功能的拓展</p><blockquote><p>问题2.2：如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p></blockquote><p>出现页访问异常后，硬件会触发中断，CPU 将产生页访问异常的线性地址 放到 cr2 寄存器中 然后就是和普通的中断一样 保护现场 将寄存器的值压入栈中 然后压入 error_code，并转到中断服务例程将外存的数据换到内存中来 ，最后 退出中断 回到进入中断前的状态</p><h2 id="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"><a href="#练习3：释放某虚地址所在的页并取消对应二级页表项的映射" class="headerlink" title="练习3：释放某虚地址所在的页并取消对应二级页表项的映射"></a>练习3：释放某虚地址所在的页并取消对应二级页表项的映射</h2><p>修改<code>pmm.c</code>中的<code>page\_remove\_pte</code>函数。</p><p>代码执行步骤为：</p><ol><li>找到页表项对应的物理页帧</li><li>将页的对应的被引用次数减一</li><li>如果ref为0，释放该页</li><li>清除页表项，并更新tlb</li></ol><pre class="line-numbers language-c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptep <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Page <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">pte2page</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">page_ref_dec</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">free_page</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">tlb_invalidate</span><span class="token punctuation">(</span>pgdir<span class="token punctuation">,</span> la<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题3.1：数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p></blockquote><p>存在对应关系：</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715175121.png" alt="img" style="zoom:50%;"><p>页目录表项和页表项的高20位为物理页表地址/物理页地址 ， 前20位表示4K对齐的该PDE对应的页表起始位置，表示它对应的是哪个Page，在页表项中存放着对应的物理页的物理地址，然后通过线性地址的最后12位找到对应页面的页内偏移位置。</p><p>那么我们可以通过将物理地址除以一个页的大小，然后乘上一个Page结构的大小获得偏移量，使用偏移量加上Page数组的基地址皆可以得到物理页所对应的Page结构体项的首地址；</p><p>在pmm.c的page_init函数中：</p><pre class="line-numbers language-c"><code class="language-c">    npage <span class="token operator">=</span> maxpa <span class="token operator">/</span> PGSIZE<span class="token punctuation">;</span>    pages <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> Page <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">ROUNDUP</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>end<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> npage<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">SetPageReserved</span><span class="token punctuation">(</span>pages <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    uintptr_t freemem <span class="token operator">=</span> <span class="token function">PADDR</span><span class="token punctuation">(</span><span class="token punctuation">(</span>uintptr_t<span class="token punctuation">)</span>pages <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> Page<span class="token punctuation">)</span> <span class="token operator">*</span> npage<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题3.2：如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？鼓励通过编程来具体完成这个问题</p></blockquote><p>在ucore中虚地址和物理地址之间有一个偏移，即存在映射关系： </p><pre class="line-numbers language-cpp"><code class="language-cpp">phy addr <span class="token operator">+</span> KERNBASE <span class="token operator">=</span> <span class="token keyword">virtual</span> addr<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> KERNBASE为虚拟地址空间中的内核基址，即偏移量。 </p><p>那么我们可以修改memlayout.h文件中 KERNBASE的值，实现虚拟地址与物理地址相等</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">define</span> KERNBASE     0x00000000</span><span class="token macro property">#<span class="token directive keyword">define</span> VPT          0x3AC00000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h3 id="列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解"><a href="#列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解" class="headerlink" title="列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解"></a>列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解</h3><ol><li>练习一涉及连续物理内存分配的first-fit算法，对应原理课的联系内存分配</li><li>练习二涉及分页机制的实现，实现了线性地址与实地址的转换过程以及页表的建立和索引，加深了我对分页机制中从线性地址到实际内存中物理地址映射这一个过程的理解</li><li>同时可以发现无论是页目录项还是页表项，都具有着一些保留的位供操作系统使用，也就是说ucore可以利用这些位来完成一些其他的内存管理相关的算法，比如可以在这些位里保存最近一段时间内该页的被访问的次数（仅能表示0-7次），用于辅助近似地实现虚拟内存管理中的换出策略的LRU之类的算法；也就是说这些保留位有利于OS进行功能的拓展</li></ol><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab07</title>
      <link href="/2020/05/16/ucore-lab07/"/>
      <url>/2020/05/16/ucore-lab07/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab07"><a href="#Ucore-Lab07" class="headerlink" title="Ucore Lab07"></a>Ucore Lab07</h1><h1 id="一、-操作系统原理"><a href="#一、-操作系统原理" class="headerlink" title="一、    操作系统原理"></a>一、    操作系统原理</h1><h2 id="1-1、同步与互斥"><a href="#1-1、同步与互斥" class="headerlink" title="1.1、同步与互斥"></a>1.1、同步与互斥</h2><p>多线程并发会导致资源竞争，为了协调多线程对共享数据的访问，使得任何时刻只能有一个线程执行临界区代码，需要系统工程师提供底层硬件支持，或者是在更高层次上提供编程的抽象</p><h4 id="基本同步方法"><a href="#基本同步方法" class="headerlink" title="基本同步方法"></a>基本同步方法</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-53dbbf52793333d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h2 id="1-2、信号量"><a href="#1-2、信号量" class="headerlink" title="1.2、信号量"></a>1.2、信号量</h2><p>信号量是操作系统提供的一种协调共享资源访问的方法</p><p>软件同步是平等线程间的一种同步协商机制(线程是平等的)，OS是管理者，地位高于进程，用信号量表示系统资源的数量。</p><p>信号量由一个整形(sem)变量(共享资源数目)和两个原子操作组成</p><ul><li><p>P()(Prolaag)，sem减1，如sem&lt;0,进入等待,否则继续</p></li><li><p>V()(Verhoog)，sem加1，如sem≤0,唤醒一个等待进程</p></li></ul><h4 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h4><ul><li><p>信号量是被保护的整数变量，初始化完成后，只能通过P()和V()操作修改，由操作系统保证，PV操作是原子操作</p></li><li><p>P()可能阻塞，V()不会阻塞</p></li><li><p>通常假定信号量是“公平的”</p></li></ul><p>自旋锁是需要占用CPU随时随地去查标志，有可能临界区的使用者退出的时候它刚改完标志，下一个进入者哪个线程去查，那它就能进去，如果说运气不好，正好是这个资源变成有效的时候，你去查的时候在你之前就有一个人已经查过了，就没有办法按照你等待的这个顺序来执行。</p><h4 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-7f972075873a6852.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h4 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h4><p>基本原理:两个或多个进程可以通过简单的信号进行合作，一个进程可以被迫在某一位置停止，直到它接收到一个特定的信号。任何复杂的合作需求都可以通过适当的信号结构得到满足，为了发信号，需要使用一个称做信号量的特殊变量。信号量分类，一种是二进制信号量：资源数目为0或1(有些系统称为互斥锁)，而对于另外一种资源信号量来说，资源数目可以为任何非负值，利用信号量可以实现对于临界区的互斥访问控制，跨进程之间的条件同，以及相对应的线程间的事件等待</p><h4 id="用信号量实现临界区的互斥访问"><a href="#用信号量实现临界区的互斥访问" class="headerlink" title="用信号量实现临界区的互斥访问"></a>用信号量实现临界区的互斥访问</h4><p>用一个信号量来对应一个临界区,,通过mutex的值来确定该资源的情况，P()减一V()加一，但mutex为负值的时候表示使用该资源的线程有在排队的，这样来实现互斥访问</p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-dde7c1906feca146.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/365/format/webp" alt="img"></p><h4 id="用信号量实现条件同步"><a href="#用信号量实现条件同步" class="headerlink" title="用信号量实现条件同步"></a>用信号量实现条件同步</h4><p>也是通过condition这个值来控制的，有一个资源B只在使用，只用通过V()操作加一后，condition的值小于等于0就知道有另一个线程A在等他，然后唤醒A。</p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-8f14247fbaae3def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/421/format/webp" alt="img"></p><h2 id="1-3、生产者-消费者问题"><a href="#1-3、生产者-消费者问题" class="headerlink" title="1.3、生产者-消费者问题"></a>1.3、生产者-消费者问题</h2><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-121cce7082f9cbe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="img"></p><h4 id="用信号量解决生产者-消费者问题"><a href="#用信号量解决生产者-消费者问题" class="headerlink" title="用信号量解决生产者-消费者问题"></a>用信号量解决生产者-消费者问题</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-524b13f7a8a9c6ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/467/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-d4b65284742e968a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/553/format/webp" alt="img"></p><h4 id="P-empty-和P-s-操作更换顺序有什么问题"><a href="#P-empty-和P-s-操作更换顺序有什么问题" class="headerlink" title="P(empty) 和P(s)操作更换顺序有什么问题"></a>P(empty) 和P(s)操作更换顺序有什么问题</h4><p>错误的顺序：</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715185912.png" alt="1587889277660" style="zoom:50%;"><p>若生产者进程已经将缓冲区放满，消费者进程并没有取产品，即 empty = 0，当下次仍然是生产者进程运行时，它先执行 P(mutex)封锁信号量，再执行 P(empty)时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行 P(mutex)，然而由于生产者进程已经封锁 mutex 信号量，消费者进程也会被阻塞，这样一来生产者进程与消费者进程都将阻塞，都指望对方唤醒自己，陷入了无休止的等待，出现死锁的现象</p><p>程序代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>Semaphore<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Integer count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建三个信号量</span>    <span class="token keyword">final</span> Semaphore notFull <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> Semaphore notEmpty <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//互斥锁</span>    <span class="token keyword">final</span> Semaphore mutex <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notFull<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">"生产者生产，目前总共有"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">class</span> <span class="token class-name">Consumer</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    notEmpty<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    mutex<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">--</span><span class="token punctuation">;</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                            <span class="token operator">+</span> <span class="token string">"消费者消费，目前总共有"</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    mutex<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    notFull<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果图：</p><p>僵持在这个情况下</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715185858.png" alt="image-20200715185858449"></p><p>SMP系统必须提供其他加锁技术(如自旋锁)，以确保wait()和signal()(即P()Ｖ())可原子地执行。</p><h2 id="1-4、管程"><a href="#1-4、管程" class="headerlink" title="1.4、管程"></a>1.4、管程</h2><p>​        管程是一种用于多线程互斥访问共享资源的程序结构，采用面向对象方法，简化了线程间的同步控制，任一时刻最多只有一个线程执行管程代码，正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</p><p>​         管程可以由两个部分组成，首先是一个锁(入口)控制管程代码的互斥访问，再有就是0或者多个条件变量去管理共享数据的并发访问，条件变量控制只允许一个线程在管程内部执行，共享数据的并发访问需要这些共享资源的时候，与相应的条件变量对应的互斥操作才能执行如果说在这个内部</p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-860f227b5575e24c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/374/format/webp" alt="img"></p><h3 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量(Condition Variable)"></a>条件变量(Condition Variable)</h3><p>条件变量是管程内的等待机制，进入管程的线程因资源被占用而进入等待状态，每个条件变量表示一种等待原因，对应一个等待队列，条件变量仅有的操作wait和signal</p><ul><li>Wait()操作</li></ul><p>将自己阻塞在等待队列中，被signal()唤醒一个等待者或释放管程的互斥访问</p><ul><li>Signal()操作</li></ul><p>将等待队列中的一个线程唤醒，如果等待队列为空，则等同空操作</p><h4 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-11e0a6feab51379a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h4 id="用管程解决生产者-消费者问题"><a href="#用管程解决生产者-消费者问题" class="headerlink" title="用管程解决生产者-消费者问题"></a>用管程解决生产者-消费者问题</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-9cd2cfd391379814.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h4 id="管程条件变量的释放处理方式"><a href="#管程条件变量的释放处理方式" class="headerlink" title="管程条件变量的释放处理方式"></a>管程条件变量的释放处理方式</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-541a9a91e0f0d131.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h4 id="Hansen管程与Hoare管程"><a href="#Hansen管程与Hoare管程" class="headerlink" title="Hansen管程与Hoare管程"></a>Hansen管程与Hoare管程</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-b6256a2496ae4942.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/533/format/webp" alt="img"></p><h2 id="1-4、哲学家就餐问题"><a href="#1-4、哲学家就餐问题" class="headerlink" title="1.4、哲学家就餐问题"></a>1.4、哲学家就餐问题</h2><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-8d319ec70ea23221.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/529/format/webp" alt="img"></p><h3 id="方案1-信号量"><a href="#方案1-信号量" class="headerlink" title="方案1(信号量)"></a>方案1(信号量)</h3><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-dc9f2685b4fd4f64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/475/format/webp" alt="img"></p><h4 id="方案2-临界区"><a href="#方案2-临界区" class="headerlink" title="方案2(临界区)"></a>方案2(临界区)</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-4eeaa5c388c9b4d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/476/format/webp" alt="img"></p><h4 id="方案3-保证每个哲学家拿起不同方向的叉"><a href="#方案3-保证每个哲学家拿起不同方向的叉" class="headerlink" title="方案3(保证每个哲学家拿起不同方向的叉)"></a>方案3(保证每个哲学家拿起不同方向的叉)</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-f49c6e5bbe08bd3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/483/format/webp" alt="img"></p><h2 id="1-5、读者-写者问题"><a href="#1-5、读者-写者问题" class="headerlink" title="1.5、读者-写者问题"></a>1.5、读者-写者问题</h2><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-216e89bde0315b53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/361/format/webp" alt="img"></p><h4 id="用信号量解决读者-写者问题"><a href="#用信号量解决读者-写者问题" class="headerlink" title="用信号量解决读者-写者问题"></a>用信号量解决读者-写者问题</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-c48ddb485ba2d3d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/261/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-46bea1254774a26f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/460/format/webp" alt="img"></p><h4 id="用管程解决读者-写者问题"><a href="#用管程解决读者-写者问题" class="headerlink" title="用管程解决读者-写者问题"></a>用管程解决读者-写者问题</h4><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-78a8b6ffa540142b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-d736315e597716e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-6ec77273afbb2769.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul><li>理解操作系统的同步互斥的设计实现；</li><li>理解底层支撑技术：禁用中断、定时器、等待队列；</li><li>在ucore中理解信号量(semaphore)机制的具体实现；</li><li>理解管程机制，在ucore内核中增加基于管程(monitor)的条件变量(condition variable)的支持；</li><li>了解经典进程同步问题，并能使用同步机制解决进程同步问题。</li></ul><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><p>​         实验六完成了用户进程的调度框架和具体的调度算法，可调度运行多个进程。如果多个进程需要协同操作或访问共享资源，则存在如何同步和有序竞争的问题。本次实验，主要是熟悉ucore的进程同步机制-信号量(semaphore)机制，以及基于信号量的哲学家就餐问题解决方案。然后掌握管程的概念和原理，并参考信号量机制，实现基于管程的条件变量机制和基于条件变量来解决哲学家就餐问题。<br>​           在本次实验中，在$kern/sync/check_sync.c$中提供了一个基于信号量的哲学家就餐问题解法。同时还需完成练习，即实现基于管程(主要是灵活运用条件变量和互斥信号量)的哲学家就餐问题解法。哲学家就餐问题描述如下：有五个哲学家，他们的生活方式是交替地进行思考和进餐。哲学家们公用一张圆桌，周围放有五把椅子，每人坐一把。在圆桌上有五个碗和五根筷子，当一个哲学家思考时，他不与其他人交谈，饥饿时便试图取用其左、右最靠近他的筷子，但他可能一根都拿不到。只有在他拿到两根筷子时，方能进餐，进餐完后，放下筷子又继续思考。   </p><h2 id="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题-不需要编码"><a href="#练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题-不需要编码" class="headerlink" title="练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题(不需要编码)"></a>练习1：理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题(不需要编码)</h2><h3 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h3><blockquote><p><strong>请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程</strong></p></blockquote><p>以下为信号量对应的数据结构:</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct {    int value;                  信号量的当前值    wait_queue_t wait_queue;    信号量对应的等待队列} semaphore_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">typedef struct {    struct proc_struct *proc;   等待进程的指针    uint32_t wakeup_flags;      进程被放入等待队列的原因标记    wait_queue_t *wait_queue;   指向此wait结构所属于的wait_queue    list_entry_t wait_link;     用来组织wait_queue中wait节点的连接} wait_t;typedef struct {    list_entry_t wait_head; // wait_queue的队头} wait_queue_t;le2wait(le, member) // 实现wait_t中成员的指针向wait_t 指针的转化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 信号量初始化完成后只能通过<code>P()</code>和<code>V()</code>修改，ucore中对应的函数为<code>down()</code>和<code>up()</code>。 </p><p> 此处需要提及的是，在原理课中的sem若为负数，则其值等于当前正在等待队列的进程的个数，通过sem的值来判断当前是否有进程正在等待该资源，而具体实现中sem最小为0，sem为0表示当前共享资源不空闲，而正在等待该资源的进程则用wait队列来表示，若为空，则当前无正在等待该资源的进程，若不为空，则唤醒对应的进程。 </p><h3 id="1-Sem-init初始化操作："><a href="#1-Sem-init初始化操作：" class="headerlink" title="1. Sem_init初始化操作："></a>1. Sem_init初始化操作：</h3><ol><li>初始化一个信号量时，将该信号量的数值初始化为给定的值，等待队列初始化为单个元素的队列(只有头哨兵)。</li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sem_init</span><span class="token punctuation">(</span>semaphore_t <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    信号量的初始化过程中需要设置初始的value值并初始化等待队列    sem<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token function">wait_queue_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>sem<span class="token operator">-></span>wait_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-V-操作时："><a href="#2-V-操作时：" class="headerlink" title="2. V()操作时："></a>2. V()操作时：</h3><ul><li><p>若等待队列为空，则信号数值加1并返回，表示该信号有富余的量；若等待队列不为空，则选取等待队列队首的元素进行唤醒。</p><ul><li>操作时需要关、开中断来保证共享变量的互斥操作。</li></ul></li></ul><pre class="line-numbers language-c++"><code class="language-c++">static __noinline void __up(semaphore_t *sem, uint32_t wait_state) { // P()    bool intr_flag;   为了保证信号量的操作不被其他进程或线程打算需要关闭中断    local_intr_save(intr_flag);    {        wait_t *wait;        如果信号量的等待队列中没有等待的进程或者线程，将value++        相当于课件的 value >= 0        if ((wait = wait_queue_first(&(sem->wait_queue))) == NULL) {            sem->value ++;        }        如果信号量的等待队列中没有等待的进程或者线程，则从队列头部取下一个等待进程(线程)并唤醒        处理方式相当于课件的 value< 0的情况(在ucore实现中value恒大于等于0)        else {            assert(wait->proc->wait_state == wait_state);            wakeup_wait(&(sem->wait_queue), wait, wait_state, 1);        }    }    local_intr_restore(intr_flag);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-P-操作时："><a href="#3-P-操作时：" class="headerlink" title="3. P()操作时："></a>3. P()操作时：</h3><ul><li>若信号量有多(value大于0)，value减少1并立即返回，表示信号量被进程消耗；</li><li>若信号量value等于0，则将当前进程放入等待队列，运行调度器以调度到其他进程。当该进程被再次调度回来时，说明进程被唤醒，且若等待进程的<code>wakeup_flags</code>没有改变，则信号量被该进程所消耗，从而可以将该进程从等待队列中删除。若等待进程的<code>wakeup_flags</code>改变，说明进程因为其他原因被唤醒，此时仍然需要将进程从等待队列中移除(因为进程被其他原因唤醒，不可以再等待该信号量)，并且返回唤醒原因。</li><li>操作时需要关、开中断来保证共享变量的互斥操作。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) { // V()    bool intr_flag;   为了保证信号量的操作不被其他进程或线程打算需要关闭中断        local_intr_save(intr_flag);    if (sem->value > 0) {        sem->value --;        local_intr_restore(intr_flag);        return 0;    }    如果信号量的 value <= 0 (实际value不会小于0)，则将当前进程(线程)放入到改信号量的等待队列中        让当前进程进入睡眠状态，主动放弃控制权，并要求OS进行调度        wait_t __wait, *wait = &__wait;    wait_current_set(&(sem->wait_queue), wait, wait_state);    local_intr_restore(intr_flag);    schedule();    local_intr_save(intr_flag);    wait_current_del(&(sem->wait_queue), wait);    local_intr_restore(intr_flag);    if (wait->wakeup_flags != wait_state) {        return wait->wakeup_flags;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同</strong></p></blockquote><h3 id="用户态进程信号量机制的设计方案"><a href="#用户态进程信号量机制的设计方案" class="headerlink" title="用户态进程信号量机制的设计方案"></a>用户态进程信号量机制的设计方案</h3><h4 id="设计方案1："><a href="#设计方案1：" class="headerlink" title="设计方案1："></a>设计方案1：</h4><p>对于用户态进程/线程来说，他们的信号量机制依然可以使用等待队列来表示此时等待调度的进程，但不同于内核级进程对于共享变量的互斥操作可以通过操作系统层面的关中断来加以实现，实现原子操作的中断禁用、Test and Set指令等均需要在内核态下运行，因此可以考虑由系统统一提供出若干个管理信号量的系统调用 ，而提供给用户态进程的信号量机制是通过系统调用来实现的。</p><h4 id="设计方案2："><a href="#设计方案2：" class="headerlink" title="设计方案2："></a>设计方案2：</h4><p>用户态进程需要可以通过哈希表的方式在内核中建立一个全局变量与互斥锁的映射关系，来保证用户态进程在访问某个共享变量时候首先需要通过中断的方式进入内核态，拿到这一把互斥锁，由内核态进程判断是否可以给用户态读写该共享变量。</p><p>相同点: 信号量机制的代码实现逻辑大致相同的，具体实现都可以是在内核代码中完成 </p><p>不同点：</p><ul><li>对于内核态信号量会存储在内核态的内核栈上，而用户态信号量则存储在内核中一段共享内存中</li><li>内核态信号量可以直接调用内核的服务，而用户态信号量需要通过系统调用接口调用内核态的服务，涉及到线程进程的上下文切换、用户态到内核态再到用户态的转换，以及进程切换过程中栈信息的保存等等。</li></ul><h2 id="练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题-需要编码"><a href="#练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题-需要编码" class="headerlink" title="练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题(需要编码)"></a>练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题(需要编码)</h2><blockquote><p><strong>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案(基于条件变量)</strong></p></blockquote><p>主要关注<code>monitor.c</code>中的代码。首先列出管程相关的数据结构：</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct monitor monitor_t;typedef struct condvar{    semaphore_t sem;        使用信号量作为管程的条件变量，通过信号量的操作可以间接完成条件变量的操作    int count;              挂在该条件变量中的进程或者线程数量    monitor_t * owner;      条件变量所属的管程} condvar_t;typedef struct monitor{    semaphore_t mutex;      二值信号量，用来互斥访问管程    semaphore_t next;       用于条件同步    int next_count;         记录signal后休眠的进程数    condvar_t *cv;          条件变量} monitor_t;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出，管程中有<code>mutex</code>信号量用于保护管程，<code>next</code>信号量用于管理等待进入管程的进程。条件变量的两个核心操作是wait和signal，具体实现依赖于信号量的P(), V()操作，接下来具体分析本实验中内核级条件变量机制的实现：</p><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><ul><li>将管程的<code>next</code>的值置0，<code>mutex</code>的值置1，表示没有进程进入、也没有进程在等待。</li><li>为条件变量分配内存并初始化，将<code>sem</code>信号量的值置0，表示没有进程在等待。</li></ul><h3 id="cond-signal函数："><a href="#cond-signal函数：" class="headerlink" title="cond_signal函数："></a><code>cond_signal</code>函数：</h3><p>将指定条件变量上等待队列中的一个线程进行唤醒，并且将控制权转交给这个进程</p><ul><li>首先进程B判断<code>cv.count</code>，判断当前的条件变量的等待队列上是否有正在等待的进程<ul><li>如果<code>cvp-&gt;count &lt;= 0</code>则表示当前没有执行<code>cond_wait</code>而睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可；</li><li>如果大于0，这表示当前有执行<code>cond_wait</code>而睡眠的进程A，因此需要通过<code>up(&amp;(cvp-&gt;sem))</code>唤醒等待在<code>cv.sem</code>上睡眠的进程A。由于只允许一个进程在管程中执行，所以一旦进程B唤醒了别人(进程A)，那么自己就需要睡眠。故让<code>monitor.next_count</code>加一，<code>down(&amp;(mtp-&gt;next))</code>实际上相当于让当前进程B进入等待。如果睡醒了，表示进程A已经访问结束，则让<code>monitor.next_count</code>减一，代表管程所拥有的signal队列减少一个元素，B进程被重新调度</li></ul></li></ul><pre class="line-numbers language-c++"><code class="language-c++">void cond_signal (condvar_t *cvp) {   monitor_t *mtp = cvp->owner;   判断当前的条件变量的等待队列上是否有正在等待的进程,如果cvp->count > 0则表示当前没有执行`cond_wait`而睡眠的进程，因此就没有被唤醒的对象了，直接函数返回即可；   if (cvp->count > 0) {          进程B唤醒了别人(进程A)，那么自己就需要睡眠。故让`monitor.next_count`加一       mtp->next_count++;       让条件变量的信号量执行up操作，此时唤醒信号量的等待队列中的进程(线程)       up(&(cvp->sem));       让管程的next信号量执行down操作，实际上相当于让当前进程B进入等待       down(&(mtp->next));       B进程被重新调度，让管程的next_count减1, 代表管程所拥有的signal队列减少一个元素       mtp->next_count--;   }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="cond-wait函数："><a href="#cond-wait函数：" class="headerlink" title="cond_wait函数："></a><code>cond_wait</code>函数：</h3><ul><li><p>用于等待某个条件变量。</p></li><li><p>如果进程A执行了<code>cond_wait</code>函数，表示此进程等待某个条件<code>Cond</code>不为真，需要睡眠。因此表示等待此条件的睡眠进程个数<code>cv.count</code>要加一，然后释放管程的锁或者唤醒一个next上的进程来释放锁。接下来会出现两种情况:</p><ul><li>如果<code>monitor.next_count</code>大于0，表示有大于等于1个进程执行<code>cond_signal</code>函数且睡在了<code>monitor.next</code>信号量上，挂在<code>monitor.next</code>信号量相关的等待队列Ｓ上，因此需要唤醒等待队列Ｓ中的一个进程B；然后进程A睡在<code>cv.sem</code>上。</li><li>如果<code>monitor.next_count</code>如果小于等于0，表示目前没有进程执行<code>cond_signal</code>函数且睡着了，那需要唤醒的是由于互斥条件限制而无法进入管程的进程，所以要唤醒睡在<br><code>monitor.mutex</code>上的进程</li></ul></li><li><p>然后进程A睡在<code>cv.sem</code>上，挂在<code>cv.sem</code>条件变量相关的等待队列Ｓ上，直到有signal信号将其唤醒，如果被其他进程唤醒了，则让<code>cv.count</code>减一，表示等待此条件的睡眠进程个数少了一个，A进程可继续执行</p></li></ul><pre class="line-numbers language-c++"><code class="language-c++">void cond_wait (condvar_t *cvp) {    cvp->count++;   修改等待在条件变量的等待队列上的进程计数    monitor_t *mtp = cvp->owner;    如果管程的next_count大于0，说明依旧有其他调用signal方法的进程在等待，则唤醒该等待进程    如果管程的next_count等于0，说明没有任何进程在等待唤醒，这时候可以直接释放临界区的锁    if (mtp->next_count > 0) {        up(&(mtp->next));    } else {        up(&(mtp->mutex));    }    让条件变量的信号量执行down操作，此时value = 0，故当前进程(线程)会睡眠进入等待队列中    down(&(cvp->sem));    进程(线程)被唤醒，重新获得控制权，等待队列的元素个数减1,修正等待队列上的进程计数    cvp->count--;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问题回答-1"><a href="#问题回答-1" class="headerlink" title="问题回答"></a>问题回答</h3><blockquote><p><em><em>首先掌握管程机制， 然后基于信号量实现完成条件变量实现， 然后用管程机制实现哲学家就餐问题的解决方案( 基于<br>条件变量) </em></em></p></blockquote><h3 id="基于条件变量和管程的哲学家就餐问题的实现"><a href="#基于条件变量和管程的哲学家就餐问题的实现" class="headerlink" title="基于条件变量和管程的哲学家就餐问题的实现"></a>基于条件变量和管程的哲学家就餐问题的实现</h3><p>关于使用条件变量来完成哲学家就餐问题的实现中，总共有两个关键函数，以及使用到了N(哲学家数量)个条件变量，在管程中，还包括了一个限制管程访问的锁还有N个用于描述哲学家状态的变量(总共有<code>EATING, THINKING, HUNGER</code>)三种状态； </p><p>一种最简单的实现思路便是每次在对于共享变量访问的时候都需要先获得管程的锁，来保证访问共享变量的时候处于RUNNABLE的进程只有一个，对于共享变量的访问是互斥访问；并且由于每个哲学家只可能占有所有需要的资源(叉子)或者干脆不占用资源，因此不会出现部分占有资源的现象，从而避免了死锁的产生；</p><h3 id="phi-take-forks-condvar函数"><a href="#phi-take-forks-condvar函数" class="headerlink" title="phi_take_forks_condvar函数"></a><code>phi_take_forks_condvar</code>函数</h3><p>表示指定的哲学家尝试获得自己所需要进餐的两把叉子，如果不能获得则阻塞</p><ul><li>给管程上锁；</li><li>将哲学家的状态修改为HUNGER；</li><li>判断当前哲学家是否有足够的资源进行就餐(相邻的哲学家是否正在进餐)；<ul><li>如果能够进餐，将自己的状态修改成EATING，然后释放锁，离开管程即可；</li><li>如果不能进餐，等待在自己对应的条件变量上，等待相邻的哲学家释放资源的时候将自己唤醒；</li></ul></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">phi_take_forks_sema</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* i：哲学家号码从0到N-1 */</span><span class="token punctuation">{</span>     获取管程的锁    <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     将自己设置为饥饿    state_condvar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> HUNGRY<span class="token punctuation">;</span>     判断当前叉子是否足够就餐    <span class="token keyword">if</span> <span class="token punctuation">(</span>state_condvar<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">!=</span> EATING <span class="token operator">&amp;&amp;</span> state_condvar<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">!=</span> EATING<span class="token punctuation">)</span> <span class="token punctuation">{</span>         state_condvar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> EATING<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 就餐</span>    <span class="token punctuation">}</span>     如果不能进餐<span class="token punctuation">,</span>等待在自己对应的条件变量上，等待相邻的哲学家释放资源的时候将自己唤醒    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"phi_take_forks_condvar: %d didn’t get fork and will wait\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        等待其他人释放资源        <span class="token function">cond_wait</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>cv <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>next_count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>    如果能够进餐<span class="token punctuation">,</span>释放锁，离开管程即可        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="phi-put-forks-condvar函数"><a href="#phi-put-forks-condvar函数" class="headerlink" title="phi_put_forks_condvar函数"></a><code>phi_put_forks_condvar</code>函数</h3><p>则是释放当前哲学家占用的叉子，并且唤醒相邻的因为得不到资源而进入等待的哲学家： </p><ul><li>首先获取管程的锁；</li><li>将自己的状态修改成THINKING；</li><li>检查相邻的哲学家是否在自己释放了叉子的占用之后满足了进餐的条件，如果满足，将其从等待中唤醒(使用<code>cond_signal</code>)；</li><li>释放锁，离开管程；</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">phi_put_forks_sema</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">/* i：哲学家号码从0到N-1 */</span><span class="token punctuation">{</span>     <span class="token function">down</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 获取管程的锁</span>    state_condvar<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> THINKING<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 停止就餐</span>    <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"phi_put_forks_condvar: %d finished eating\n"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">phi_test_condvar</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> N <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>  判断左右邻居的哲学家是否可以从等待就餐的状态中恢复过来    <span class="token function">phi_test_condvar</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>next_count<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token function">up</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>mtp<span class="token operator">-></span>mutex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问题回答-2"><a href="#问题回答-2" class="headerlink" title="问题回答"></a>问题回答</h3><blockquote><p> 请在实验报告中给出给用户态进程/线程提供条件变量机制的设计方案，并比较说明给内核级提供条件变量机制的异同。</p></blockquote><ul><li>本实验中管程的实现中互斥访问的保证是完全基于信号量的，也就是如果按照上文中的说明使用<code>syscall</code>实现了用户态的信号量的实现机制，那么就完全可以按照相同的逻辑在用户态实现管程机制和条件变量机制，对条件变量的访问操作可以封装成系统调用</li><li>异同点为： <ul><li>相同点：基本的实现逻辑相同；</li><li>不同点：最终在用户态下实现管程和条件变量机制，需要使用到操作系统使用系统调用提供一定的支持; 而在内核态下实现条件变量是不需要的；</li></ul></li></ul><blockquote><p> 请在实验报告中回答：能否不用基于信号量机制来完成条件变量？如果不能，请给出理由， 如果能，请给出设计说明和具体实现。</p></blockquote><p>可以。这边的条件变量可以选择参照实验课对于条件变量的实现，条件变量维护者着两个信息，一个是等待队列，一个是目前在这个条件变量上等待的进程数目，再通过开关中断的方式来完成<code>cond_wait</code>和<code>cond_signal</code>的原子性 </p><p><img src="https:////upload-images.jianshu.io/upload_images/8542527-11e0a6feab51379a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p><ol><li>首先定义条件变量的结构体。其中需要一个计数器<code>count</code>来记录等待的进程数和一个等待队列<code>wait_queue</code></li></ol><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> count<span class="token punctuation">;</span>    wait_queue_t wait_queue<span class="token punctuation">;</span><span class="token punctuation">}</span> cond_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><code>signal</code>函数：<ul><li>关中断以保证其原子性 ，选择等待队列中第一个进程，移出等待队列并唤醒该进程(若等待队列不为空)，开中断，调度。</li></ul></li><li><code>wait</code>函数：<ul><li>关中断以保证其原子性 ， 随后判断count是否为0，若为0则表明没有进程在占用该资源，直接继续执行即可；否则将自身挂起等待别的进程唤醒，加到等待队列尾部，开中断，调度。</li><li>再次切换到该进程时，表示该进程已经被<code>signal</code>操作唤醒，已出等待队列。此时进程重新占有对等待队列的锁即可。</li></ul></li></ol><p>因此，通过开关中断的方式保证了操作的原子性，某个条件变量只能有一个进程占有，其余进程都挂在等待队列上。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h3 id="本实验中重要的知识点，以及与对应的OS原理中的知识点"><a href="#本实验中重要的知识点，以及与对应的OS原理中的知识点" class="headerlink" title="本实验中重要的知识点，以及与对应的OS原理中的知识点"></a>本实验中重要的知识点，以及与对应的OS原理中的知识点</h3><ol><li>禁用中断的同步方法</li><li>信号量</li><li>条件变量、管程</li><li>哲学家就餐问题</li></ol><h3 id="本实验中没有对应的"><a href="#本实验中没有对应的" class="headerlink" title="本实验中没有对应的"></a>本实验中没有对应的</h3><ol start="2"><li>读者-写者问题</li><li>死锁</li><li>进程间通信</li></ol>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab06</title>
      <link href="/2020/05/16/ucore-lab06/"/>
      <url>/2020/05/16/ucore-lab06/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab06"><a href="#Ucore-Lab06" class="headerlink" title="Ucore Lab06"></a>Ucore Lab06</h1><h1 id="一、-操作系统原理"><a href="#一、-操作系统原理" class="headerlink" title="一、    操作系统原理"></a>一、    操作系统原理</h1><h2 id="1-1、-实验目的"><a href="#1-1、-实验目的" class="headerlink" title="1.1、  实验目的"></a>1.1、  实验目的</h2><ul><li>理解操作系统的调度管理机制;</li><li>熟悉 ucore 的系统调度器框架，以及缺省的Round-Robin 调度算法;</li><li>基于调度器框架实现一个(Stride Scheduling)调度算法来替换缺省的调度算法;</li></ul><h2 id="1-2、进程调度的指标"><a href="#1-2、进程调度的指标" class="headerlink" title="1.2、进程调度的指标"></a>1.2、进程调度的指标</h2><p>不同的进程调度算法具有不同的特征，为此需要建立衡量一个算法的基本指标。一般而言，衡量和比较各种进程调度算法性能的主要因素如下所示：</p><ul><li>CPU利用率：CPU是计算机系统中的稀缺资源，所以应在有具体任务的情况下尽可能使CPU保持忙，从而使得CPU资源利用率最高。</li><li>吞吐量：CPU运行时的工作量大小是以每单位时间所完成的进程数目来描述的，即称为吞吐量。<br>·周转时间：指从进程创建到作进程结束所经过的时间，这期间包括了由于各种因素（比如等待I/0操作完成）导致的进程阻塞，处于就绪态并在就绪队列中排队，在处理机上运行所花时间的总和。</li><li>等待时间：即进程在就绪队列中等待所花的时间总和。因此衡量一个调度算法的简单方法就是统计进程在就绪队列上的等待时间。</li><li>响应时间：指从事件（比如产生了一次时钟中断事件）产生到进程或系统作出响应所经过的时间。在交互式桌面计算机系统中，用户希望响应时间越快越好，但这常常要以牺牲吞吐量为代价。</li></ul><h2 id="1-3、进程调度的方式"><a href="#1-3、进程调度的方式" class="headerlink" title="1.3、进程调度的方式"></a>1.3、进程调度的方式</h2><p>进程调度发生的时机（也称为调度点）与进程的状态变化有直接的关系。回顾进程状态变化图，我们可以看到进程调度的时机直接与进程在运行态&lt;-&gt;退出态/就绪态/阻塞态的转变时机相关。简而言之，引起进程调度的时机可归结为以下几类：</p><ul><li>正在执行的进程执行完毕，需要选择新的就绪进程执行。</li><li>正在执行的进程调用相关系统调用（包括与I/0操作，同步互斥操作等相关的系统调用）导致需等待某事件发生或等待资源可用，从而将白己阻塞起来进入阻塞状态。</li><li>正在执行的进程主动调用放弃CPU的系统调用，导致自己的状态为就绪态，且把自己重新放到就绪队列中。</li><li>等待事件发生或资源可用的进程等待队列，从而导致进程从阻塞态回到就绪态，并可参与到调度中。</li><li>正在执行的进程的时间片已经用完，致自己的状态为就绪态，且把自己重新放到就绪队列中。</li><li>在执行完系统调用后准备返回用户进程前的时刻，可调度选择一新用户进程执行</li><li>就绪队列中某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。</li></ul><h2 id="1-4、进程调度的策略与算法"><a href="#1-4、进程调度的策略与算法" class="headerlink" title="1.4、进程调度的策略与算法"></a>1.4、进程调度的策略与算法</h2><p>​         在早期操作系统的调度方式大多数是非剥夺的，这是由于早期的应用一般是科学计算或事务处理，不太把人机交互的响应时间指标放在首要位置。在这种情况下，正在运行的进程可一直占用CPU直到进程阻塞或终止。这种方式的调度算法可以很简单，且比较适用对于响应时间不关心或者关心甚少的科学计算或事务处理应用。随着计算机的应用领域进一步扩展，计算机更多地用在了多媒体等人机交互应用上，为此采用可抢占式的调度方式可在一个进程终止或阻塞之前就剥夺其执行权，把cPU尽快分配给另外的“更重要”进程，使得就绪队列中的进程有机会响应它们用户的I0事件。基于这两种方式的调度算法如下：</p><ul><li><p>先来先服务（FCFS）调度算法：处于就绪态的进程按先后顺序链入到就绪队列中，而FCFS调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。FCFS调度算法采用的是不可抢占的调度方式，一旦一个进程占有处理机，就一直运行下去，直到该进程完成其工作，或因等待某一事件而不能继续执行时，才释放处理机。操作系统如果采用这种进程调度方式，则一个运行时间长且正在运行的进程会使很多晚到的且运行时间短的进程的等待时间过长。</p></li><li><p>短作业优先（SJF）调度算法：其实目前作业的提法越来越少，我们姑且把“作业”用“进程”来替换，改称为短进程优先调度算法，此算法选择就绪队列中确切（或估计）运行时间最短的进程进入执行。它既可采用可抢占调度方式，也可采用不可抢占调度方式。可抢占的短进程优先调度算法通常也叫做最短剩余时间优先（Shortest Remaining Time First，SRTF）调度算法。短进程优先调度算法能有效地缩短进程的平均周转时间，提高系统的吞吐量，但不利于长进程的运行。而且如果进程的运行时间是“估计”出来的话，会导致由于估计的运行时间不一定准确，而不能实际做到短作业优先。</p></li><li><p>时间片轮转（RR）调度算法：RR调度算法与FCFS调度算法在选择进程上类似，但在调度的时机选择上不同。RR调度算法定义了一个的时间单元，称为时间片（或时间量）。一个时间片通常在1~100ms之间。当正在运行的进程用完了时间片后，即使此进程还要运行，操作系统也不让它继续运行，而是从就绪队列依次选择下一个处于就绪态的进程执行，而被剥夺CPU使用的进程返回到就绪队列的末尾，等待再次被调度。时间片的大小可调整，如果时间片大到让一个进程足以完成其全部工作，这种算法就退化为FCFS调度算法；若时间片设置得很小，那么处理机在进程之间的进程上下文切换工作过于频繁，使得真正用于运行用户程序的时间减少。时间片可以静态设置好，也可根据系统当前负载状况和运行情况动态调整，时间片大小的动态调整需要考虑就绪态进程个数、进程上下文切换开销、系统吞吐量、系统响应时间等多方面因素。</p></li><li><p>高响应比优先（Highest Response Ratio First，HRRF）调度算法：HRRF调度算法是介于先来先服务算法与最短进程优先算法之间的一种折中算法。先来先服务算法只考虑进程的等待时间而忽视了进程的执行时间，而最短进程优先调度算法只考虑用户估计的进程的执行时间而忽视了就绪进程的等待时间。HRRF调度算法二者兼顾，既考虑进程等待时间，又考虑进程的执行时间，为此定义了响应比（Rp）这个指标：<code>Rp=（等待时间+预计执行时间）/执行时间=响应时间/执行时间</code></p><p>上个表达式假设等待时间与预计执行时间之和等于响应时间。HRRF调度算法将选择Rp最大值的进程执行，这样既照顾了短进程又不使长进程的等待时间过长，改进了调度性能。但HRRF调度算法需要每次计算各各个进程的响应比Rp，这会带来较大的时间开销（特别是在就绪进程个数多的情况下）。</p></li><li><p>多级反馈队列（Multi-Level Feedback Queue）调度算法：在采用多级反馈队列调度算法的执行逻辑流程如下：</p><ul><li>设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二队次之，其余队列优先级依次降低。仅当第1~i-1个队列均为空时，操作系统调度器才会调度第i个队列中的进程运行。赋予各个队列中进程执行时间片的大小也各不相同。在优先级越高的队列中，每个进程的执行时间片就越小或越大（Linux-2.4内核就是采用这种方式）。当一个就绪进程需要链入就绪队列时，操作系统首先将它放入第一队列的未尾，按FCFS的原则排队等待调度。若轮到该进程执行且在一个时间片结束时尚未完成，则操作系统调度器便将该进程转入第二队列的末尾，再同样按先来先服务原则等待调度执行。如此下去，当一个长进程从第一队列降到最后一个队列后，在最后一个队列中，可使用FCFS或RR调度算法来运行处于此队列中的进程。</li><li>如果处理机正在第i（i&gt;1）队列中为某进程服务时，又有新进程进入第k（k&lt;i）的队列，则新进程将抢占正在运行进程的处理机，即由调度程序把正在执行进程放回第i队列未尾，重新将处理机分配给处于第k队列的新进程。</li><li>从MLFQ调度算法可以看出长进程无法长期占用处理机，且系统的响应时间会缩短，吞吐量也不错（前提是没有频繁的短进程）。所以MLFQ调度算法是一种合适不同类型应用特征的综合进程调度算法</li></ul></li><li><p>最高优先级优先调度算法：进程的优先级用于表示进程的重要性及运行的优先性。一个进程的优先级可分为两种：静态优先级和动态优先级。静态优先级是在创建进程时确定的。一旦确定后，在整个进程运行期间不再改变。静态优先级一般由用户依据包括进程的类型、进程所使用的资源、进程的估计运行时间等因素来设置。一般而言，若进程需要的资源越多、估计运行的时间越长，则进程的优先级越低；反之，对于I/0bounded的进程可以把优先级设置得高。动态优先级是指在进程运行过程中，根据进程执行情况的变化来调整优先级。动态优先级一般根据进程占有CPU时间的长短、进程等待CPU时间的长短等因素确定。占有处理机的时间越长，则优先级越低，等待时间越长，优先级越高。那么进程调度器将根据静态优先级和动态优先级的总和现在优先级最高的就绪进程执行。</p></li></ul><p>​         操作系统中为了能够让每个进程都有机会运行，需要给每个进程分配一个时间片，当一个进程的时间片用完以后，操作系统的调度器就会让当前进程放弃CPU，而选择另外一个进程占用CPU执行。为了有效地支持进程调度所需的时间片，ucore设计并实现了一个timer（计时器）功能。这样，通过timer就对基于时间事件的调度机制提供了基本支持。</p><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><h2 id="练习0：填写已有实验"><a href="#练习0：填写已有实验" class="headerlink" title="练习0：填写已有实验"></a>练习0：填写已有实验</h2><p>在本练习中将LAB1/2/3/4/5的实验内容移植到了LAB6的实验框架内，使用diff和patch工具进行自动化的移植，具体使用的命令如下所示：（对于patch工具进行合并的时候产生冲突的少部分内容，则使用<em>.rej, </em>.orig文件来手动解决冲突问题）</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">diff</span> -r -u -P lab5_origin lab5 <span class="token operator">></span> lab5.patch<span class="token function">cd</span> lab6patch -p1 -u <span class="token operator">&lt;</span> <span class="token punctuation">..</span>/lab5.patch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="练习1：使用-Round-Robin-调度算法（不需要编码）"><a href="#练习1：使用-Round-Robin-调度算法（不需要编码）" class="headerlink" title="练习1：使用 Round Robin 调度算法（不需要编码）"></a>练习1：使用 Round Robin 调度算法（不需要编码）</h2><blockquote><p><strong>请理解并分析sched_calss中各个函数指针的用法，并接合Round Robin 调度算法描述ucore的调度执行过程</strong></p></blockquote><p>通过diff工具对lab5和lab进行比较，发现主要的区别有： </p><ul><li>PCT中增加了三个与stride调度算法相关的成员变量，以及增加了对应的初始化过程；</li><li>新增了斜堆数据结构的实现；</li><li>新增了默认的调度算法Round Robin的实现，具体为调用sched_class_<em>等一系列函数之后，进一步调用调度器sched_class中封装的函数，默认该调度器为Round Robin调度器，这是在default_sched.</em>中定义的；</li><li>新增了set_priority，get_time的系统调用；</li></ul><h4 id="问题回答"><a href="#问题回答" class="headerlink" title="问题回答"></a>问题回答</h4><blockquote><p><strong>请理解并分析sched_calss中各个函数指针的用法，并结合Round Robin 调度算法描述ucore的调度执行过程;</strong></p></blockquote><ul><li><h5 id="查看sched-class-结构体"><a href="#查看sched-class-结构体" class="headerlink" title="查看sched_class 结构体"></a>查看sched_class 结构体</h5></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">struct</span> sched_class <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调度器名称</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 队列数据结构</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>init<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将进程加入调度器队列</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>enqueue<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将进程从调度器队列中移除</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dequeue<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取调度器选择的进程</span>    <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>pick_next<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 更新调度器的时钟信息</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>proc_tick<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><h5 id="ucore的调度执行过程：Round-Robin-调度算法"><a href="#ucore的调度执行过程：Round-Robin-调度算法" class="headerlink" title="ucore的调度执行过程：Round Robin 调度算法"></a>ucore的调度执行过程：Round Robin 调度算法</h5><p>RR调度算法的就绪队列在组织结构上也是一个双向链表，而增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。同时在进程控制块<code>proc_struct</code>中增加了一个成员变量<code>time_slice</code>，用来记录进程当前的可运行时间片段。<br>在每个timer到时的时候， 操作系统会递减当前执行进程的<code>time_slice</code>， 当<code>time_silce</code>为0时， 就<br>意味着这个进程已经使用完了可以使用的时间片，此时需要把CPU让渡给其他进程执行，操作系统就需要让此进程重新回到rq的队列尾， 且重置此进程的时间片为就绪队列的成员变量最大时间片<code>max_time_slice</code>值， 然后再从rq的队列头取出一个新的进程执行</p><h5 id="调度器初始化"><a href="#调度器初始化" class="headerlink" title="调度器初始化"></a>调度器初始化</h5><p>实验6增加了调度初始化函数<code>sched_init</code>，需要内核初始化过程中调用这个函数，这个函数负责选择调度器并且对选择的调度器进行初始化。</p><pre class="line-numbers language-c++"><code class="language-c++">static void RR_init(struct run_queue *rq) {    list_init(&(rq->run_list));    rq->proc_num = 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h5 id="将进程加入调度器"><a href="#将进程加入调度器" class="headerlink" title="将进程加入调度器"></a>将进程加入调度器</h5><p>在 RR调度中 ,在切换进程之前或者进程在某种情况被阻塞时候调用<code>sched_class_enqueue</code>将当前进程加入到RR的调度链表就绪队列的队尾，并将其时间片进行重置，这表示如果进程在当前的执行时间片已经用完，需要等到下一次CPU进行进程调度</p><pre class="line-numbers language-c++"><code class="language-c++">static void RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {    assert(list_empty(&(proc->run_link)));    list_add_before(&(rq->run_list), &(proc->run_link));    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {        proc->time_slice = rq->max_time_slice;    }    proc->rq = rq;    rq->proc_num ++;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h5></li></ul><ul><li><p>调用<code>sched_class_pick_next</code>获取RR算法选取的下一个进程占用处理机去运行，在RR调度中直接按照就绪队列的顺序轮询；</p></li><li><p>调用<code>sched_class_dequeue</code>将即将运行的进程从RR算法调度链表中删除。当需要取出执行的下一个进程的时候，只需要将就绪队列的队头取出即可</p><pre class="line-numbers language-c++"><code class="language-c++">static struct proc_struct * RR_pick_next(struct run_queue *rq) {    list_entry_t *le = list_next(&(rq->run_list));    if (le != &(rq->run_list)) {        return le2proc(le, run_link);    }    return NULL;}static void RR_dequeue(struct run_queue *rq, struct proc_struct *proc) {    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);    list_del_init(&(proc->run_link));    rq->proc_num --;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="调度器时钟更新"><a href="#调度器时钟更新" class="headerlink" title="调度器时钟更新"></a>调度器时钟更新</h5><p>每次timer时钟中断时，需要调用<code>sched_class_proc_tick</code>更新调度器中的时钟，<code>trap</code>函数将会间接调用此函数来把当前执行进程的时间片<code>time_slice</code>减一，减少当前进程时间片<br>当<code>time_slice</code>降到零， 则设置此进程成员变量need_resched标识为1， 这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量need_resched标识为1而执行schedule函数， 从而把当前执行进程放回就绪队列末尾， 而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。</p><pre class="line-numbers language-c++"><code class="language-c++">static void RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {    if (proc->time_slice > 0) {        proc->time_slice --;    }    if (proc->time_slice == 0) {        proc->need_resched = 1;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p><strong>问题1.2：请在实验报告中简要说明如何设计实现”多级反馈队列调度算法”，给出概要设计，鼓励给出详细设计</strong></p></blockquote><h4 id="多级反馈队列详细设计"><a href="#多级反馈队列详细设计" class="headerlink" title="多级反馈队列详细设计"></a>多级反馈队列详细设计</h4><ul><li><p>多级反馈队列调度算法可以看做是对RR算法的进一步扩展，在<code>proc_struct</code>中将一个<code>rq</code>队列扩展为N个多级反馈队列的入口，确保了长时间运行的进程优先级会随着执行时间的增加而降低， 而短时间运行的进程会优于长时间运行的进程被先调度执行</p></li><li><p>每个队列都有着各自的优先级，编号越大的队列优先级约低，并且优先级越低的队列上时间片的长度越大，为其上一个优先级队列的两倍</p></li><li><p>在进程的PCB进程控制块中记录当前进程所处的队列的优先级</p></li></ul><h5 id="MFQS-init"><a href="#MFQS-init" class="headerlink" title="MFQS_init"></a>MFQS_init</h5><ul><li>处理调度算法初始化的时候需要同时对N个队列进行初始化</li><li>在同一个优先级的队列内使用时间片轮转算法</li></ul><h5 id="MFQS-enqueue"><a href="#MFQS-enqueue" class="headerlink" title="MFQS_enqueue"></a>MFQS_enqueue</h5><ul><li>多级反馈队列调度算法维护多个队列，每个新的进程在刚开始的时候加入$Q_0$中</li><li>在处理将进程加入到就绪进程集合的时候，观察这个进程的时间片有没有使用完<ul><li>如果来自$$Q_i$$某个进程在时间片用完之后没结束，那么将这个进程加入优先级低1级$$Q_{i+1}$$队列中，时间片加倍。</li><li>如果没有使用完时间片，则加入到当前优先级的队列中去</li></ul></li></ul><h5 id="MFQS-dequeue"><a href="#MFQS-dequeue" class="headerlink" title="MFQS_dequeue"></a>MFQS_dequeue</h5><ul><li>从就绪进程集合中删除某一个进程就只需要在对应队列中删除即可</li></ul><h5 id="MFQS-pick-next"><a href="#MFQS-pick-next" class="headerlink" title="MFQS_pick_next"></a>MFQS_pick_next</h5><ul><li>在选择下一个执行的进程的时候，优先去考虑高优先级的队列中是否存在任务，如果不存在才转而寻找较低优先级的队列，每次选择进程执行的之后从$$Q_0$$开始向$$Q_n$$查找，如果某个队列非空，那么从这个队列中取出一个进程</li></ul><h5 id="MFQS-proc-tick"><a href="#MFQS-proc-tick" class="headerlink" title="MFQS_proc_tick"></a>MFQS_proc_tick</h5><ul><li>处理时间中断的函数不需要改变</li></ul><h2 id="练习2：实现-Stride-Scheduling-调度算法（需要编码）"><a href="#练习2：实现-Stride-Scheduling-调度算法（需要编码）" class="headerlink" title="练习2：实现 Stride Scheduling 调度算法（需要编码）"></a>练习2：实现 Stride Scheduling 调度算法（需要编码）</h2><blockquote><p><strong>实验指导书：首先需要换掉RR调度器的实现，即用default_sched_stride_c覆盖default_sched.c。然后根据 此文件和后续文档对Stride度器的相关描述，完成Stride调度算法的实现。</strong></p></blockquote><p>由于在ucore中使用面向对象编程的思想，将所有与调度算法相关的函数封装在了调度器<code>sched_class</code>中，因此其实可以不需要覆盖掉<code>default_sched.c</code>，只需要将<code>default_sched_c</code>改名<code>default_sched_stride.c</code>，然后注释掉<code>default_sched.c</code>中的<code>sched_class</code>的定义，那么当调用调度器的接口的时候就直接调用了新实现的<code>Stride Scheduling</code>算法实现的函数了；</p><p>与此同时, 本次实验提供了<code>libs/skew_heap.h</code>作为优先队列的一个实现，该实现定义相关的结构和接口，其中主要包括： </p><pre class="line-numbers language-c++"><code class="language-c++">   // 优先队列节点的结构   typedef struct skew_heap_entry  skew_heap_entry_t;   // 初始化一个队列节点   void skew_heap_init(skew_heap_entry_t *a);   // 将节点 b 插入至以节点 a 为队列头的队列中去，返回插入后的队列   skew_heap_entry_t  *skew_heap_insert(skew_heap_entry_t  *a,                                        skew_heap_entry_t  *b,                                        compare_f comp);   // 将节点 b 插入从以节点 a 为队列头的队列中去，返回删除后的队列      skew_heap_entry_t  *skew_heap_remove(skew_heap_entry_t  *a,                                           skew_heap_entry_t  *b,                                           compare_f comp);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现思路："><a href="#实现思路：" class="headerlink" title="实现思路："></a>实现思路：</h3><p>考察round-robin 调度器，在假设所有进程都充分使用了其拥有的CPU时间资源的情况下，所有进程得到的CPU时间应该是相等的。但是有时候我们希望调度器能够更智能地为每个进程分配合理的CPU资源。假设我们为不同的进程分配不同的优先级，则我们有可能希望每个进程得到的时间资源与他们的优先级成正比关系。Stride调度是基于这种想法的一个较为典型和简单的算法。除了简单易于实现以外，它还有如下的特点：</p><ul><li>可控性：如我们之前所希望的，可以证明 Stride Scheduling对进程的调度次数正比于其优先级。</li><li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。该算法的基本思想可以考虑如下：<br>$i.$为每个runnab1e的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride需要进行的累加值。<br>$ii.$每次需要调度时，从当前runnab1e态的进程中选择stride最小的进程调度，所以在这边引入斜堆的概念在$o(logn)$的复杂度里找到stride最小的进程<br>$iii.$对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。<br>$iv.$在一段固定的时间之后，回到2.步骤，重新调度当前stride最小的进程。<br>可以证明，如果令$P.pass =Bigstride/P.priority$ 其中$P.priority$表示进程的优先权（大于1），而$Bigstride$表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</li></ul><h3 id="具体实现："><a href="#具体实现：" class="headerlink" title="具体实现："></a>具体实现：</h3><h4 id="stride-init"><a href="#stride-init" class="headerlink" title="stride_init"></a>stride_init</h4><p>Stride Scheduling需要使用优先队列来决定下一个需要调度的进程，所以需要：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stride_init</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">)</span>     <span class="token function">list_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rq<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">;</span>         rq<span class="token operator">-></span>lab6_run_pool <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 对斜堆进行初始化，表示有限队列为空</span>        rq<span class="token operator">-></span>proc_num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 将进程数目初始化为0。 </span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="stride-enqueue"><a href="#stride-enqueue" class="headerlink" title="stride_enqueue"></a>stride_enqueue</h4><ul><li>在将指定进程加入就绪队列的时候，如果使用优先队列，则调用斜堆的插入函数将其插入到斜堆中，然后对时间片等信息进行更新，则直接插入优先队列中；否则将进程插入到链表末端</li><li>更新进程的剩余时间片；</li><li>设置进程的队列指针<code>proc-&gt;rq</code>置为当前<code>rq</code>；</li><li>增加进程计数值<code>proc_num</code>。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stride_enqueue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token macro property">#<span class="token directive keyword">if</span> USE_SKEW_HEAP</span>  rq<span class="token operator">-></span>lab6_run_pool <span class="token operator">=</span> <span class="token function">skew_heap_insert</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">,</span> <span class="token operator">&amp;</span>proc<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">,</span> proc_stride_comp_f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将新的进程插入到表示就绪队列的斜堆中，该函数的返回结果是斜堆的新的根</span>  <span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">list_add_before</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>proc<span class="token operator">-></span>run_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>proc<span class="token operator">-></span>time_slice <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> proc<span class="token operator">-></span>time_slice <span class="token operator">></span> rq<span class="token operator">-></span>max_time_slice<span class="token punctuation">)</span> <span class="token punctuation">{</span>    proc<span class="token operator">-></span>time_slice <span class="token operator">=</span> rq<span class="token operator">-></span>max_time_slice<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 将该进程剩余时间置为时间片大小</span>  <span class="token punctuation">}</span>  proc<span class="token operator">-></span>rq <span class="token operator">=</span> rq<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新进程的就绪队列</span>  rq<span class="token operator">-></span>proc_num <span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 维护就绪队列中进程的数量</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="stride-dequeue"><a href="#stride-dequeue" class="headerlink" title="stride_dequeue"></a>stride_dequeue</h4><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">stride_dequeue</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token macro property">#<span class="token directive keyword">if</span> USE_SKEW_HEAP</span>    rq<span class="token operator">-></span>lab6_run_pool <span class="token operator">=</span> <span class="token function">skew_heap_remove</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>proc<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">)</span><span class="token punctuation">,</span> proc_stride_comp_f<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//将进程从优先队列中移除；</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    <span class="token function">list_del_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>proc<span class="token operator">-></span>run_link<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    rq<span class="token operator">-></span>proc_num<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将进程计数值减一。</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="stride-pick-next"><a href="#stride-pick-next" class="headerlink" title="stride_pick_next"></a>stride_pick_next</h4><ul><li>如果队列为空，返回空指针；</li><li>选择下一个要执行的进程，根据stride算法，只需要选择stride值最小的进程，即斜堆的根节点对应的进程即可从优先队列中获得一个进程（就是指针所指的进程控制块）；</li><li>更新stride值。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span><span class="token function">stride_pick_next</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token macro property">#<span class="token directive keyword">if</span> USE_SKEW_HEAP</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rq<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">le2proc</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>lab6_run_pool<span class="token punctuation">,</span> lab6_run_pool<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token macro property">#<span class="token directive keyword">else</span></span>    list_entry_t <span class="token operator">*</span>le <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>le <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">le2proc</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> run_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>le <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span>le<span class="token punctuation">)</span><span class="token punctuation">;</span> le <span class="token operator">!=</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span>rq<span class="token operator">-></span>run_list<span class="token punctuation">)</span><span class="token punctuation">;</span> le <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span>le<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token function">le2proc</span><span class="token punctuation">(</span>le<span class="token punctuation">,</span> run_link<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>int32_t<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lab6_stride <span class="token operator">-</span> p1<span class="token operator">-></span>lab6_stride<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            p <span class="token operator">=</span> p1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">endif</span></span>    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token operator">-></span>lab6_priority <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>lab6_stride <span class="token operator">+</span><span class="token operator">=</span> BIG_STRIDE<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        p<span class="token operator">-></span>lab6_stride <span class="token operator">+</span><span class="token operator">=</span> BIG_STRIDE <span class="token operator">/</span> p<span class="token operator">-></span>lab6_priority<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="stride-proc-tick"><a href="#stride-proc-tick" class="headerlink" title="stride_proc_tick"></a>stride_proc_tick</h4><p>这部分和RR算法保持一致了，判断当前进程的时间片个数是否大于零，如果是则减一，否则将<code>need_resched</code>置1，在下次时钟中断时进行切换进程。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span><span class="token function">stride_proc_tick</span><span class="token punctuation">(</span><span class="token keyword">struct</span> run_queue <span class="token operator">*</span>rq<span class="token punctuation">,</span> <span class="token keyword">struct</span> proc_struct <span class="token operator">*</span>proc<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/* LAB6: YOUR CODE */</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>proc<span class="token operator">-></span>time_slice <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        proc<span class="token operator">-></span>time_slice<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>proc<span class="token operator">-></span>time_slice <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        proc<span class="token operator">-></span>need_resched <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><h4 id="列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）"><a href="#列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）" class="headerlink" title="列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）"></a>列出你认为本实验中重要的知识点，以及与对应的OS原理中的知识点，并简要说明你对二者的含义，关系，差异等方面的理解（也可能出现实验中的知识点没有对应的原理知识点）</h4><ul><li>三种调度算法的具体实现：<ul><li>Round-Robin调度算法；</li><li>Stride调度算法；</li><li>多级反馈队列调度算法；</li></ul></li><li>ucore中使用面向对象的思想实现了<code>sched_class</code>,对调度算法框架进行了具体的封装，通过高层次抽象简化后者的具体实现过程</li></ul><pre class="line-numbers language-c++"><code class="language-c++">struct sched_class {    // 调度器名称    const char *name;    // 队列数据结构    void (*init)(struct run_queue *rq);    // 将进程加入调度器队列    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);    // 将进程从调度器队列中移除    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);    // 获取调度器选择的进程    struct proc_struct *(*pick_next)(struct run_queue *rq);    // 更新调度器的时钟信息    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab05</title>
      <link href="/2020/05/16/ucore-lab05/"/>
      <url>/2020/05/16/ucore-lab05/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab05"><a href="#Ucore-Lab05" class="headerlink" title="Ucore Lab05"></a>Ucore Lab05</h1><h1 id="一、-操作系统原理"><a href="#一、-操作系统原理" class="headerlink" title="一、    操作系统原理"></a>一、    操作系统原理</h1><h2 id="1-1、-进程的状态转换"><a href="#1-1、-进程的状态转换" class="headerlink" title="1.1、  进程的状态转换"></a>1.1、  进程的状态转换</h2><h4 id="进程的三态模型"><a href="#进程的三态模型" class="headerlink" title="进程的三态模型"></a>进程的三态模型</h4><ul><li><p>运行态指进程占有处理器运行，处于运行态的进程个数不能大于处理器个数</p></li><li><p>就绪态指进程具备运行条件等待处理器运行</p></li><li><p>等待态指进程由于等待资源、输入输出、信号等而不具备运行条件</p><p>（1）运行态→等待态：出现等待事件，如等待资源、I/O、信号</p><p>（2）等待态→就绪态：等待事件完成，如资源满足、I/O结束、信号完成</p><p>（3）就绪态→运行态：处理器空闲时会选择更高优先权进程抢占</p><p>（4）运行态→就绪态：运行时间片到、有更高优先权进程</p><p>OS无法预期进程的数目与资源需求，计算机系统在运行过程中可能出现资源不足的情况，运行资源不足表现为性能低和死锁两种情况。 解决办法为进程挂起：剥夺某些进程的内存及其他资源，调入OS管理的对换区，不参加进程调度，待适当时候再调入内存、恢复资源、参与运行</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715162644.png" alt="image-20200715154745687"></p></li><li><p>一般选择等待态进程进入挂起等待态，也可选择就绪态进程进入挂起就绪态，运行态进程还可以挂起自己进入挂起就绪态</p></li><li><p>等待事件结束后，挂起等待态进入挂起就绪态，一般选择挂起就绪态进程予以恢复</p></li><li><p>挂起态与等待态有着本质区别，等待态占有已申请到的资源处于等待，挂起态没有任何资源</p></li></ul><h2 id="1-2、系统-中断响应的处理流程"><a href="#1-2、系统-中断响应的处理流程" class="headerlink" title="1.2、系统 中断响应的处理流程"></a>1.2、系统 中断响应的处理流程</h2><p>非屏蔽中断和异常的编号是固定的， 而屏蔽中断的编号可以通过对中断控制器的编程来调整。</p><p> 256个中断的分配如下：</p><ul><li>0~31号的中断对应于故障、 陷阱和非屏蔽外设中断。</li><li>32~47号的中断分配给可屏蔽外设中断。 </li><li>48~255号的中断可以用软件来设置，可以调用其中的一个中断号来实现系统调用。  </li></ul><p>​            <img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715161601.png" alt>                                                                                              </p><h3 id="具体的执行流程"><a href="#具体的执行流程" class="headerlink" title="具体的执行流程"></a>具体的执行流程</h3><p><strong>(1) 中断响应的事前准备：</strong></p><p>　　系统要想能够应对各种不同的中断信号，总的来看就是需要知道每种信号应该由哪个中断服务程序负责以及这些中断服务程序具体是如何工作的。系统只有事前对这两件事都知道得很清楚，才能正确地响应各种中断信号和异常。</p><ul><li><p>系统将所有的中断信号统一进行了编号（一共256个：0～255），这个号称为中断向量，具体哪个中断向量表示哪种中断有的是规定好的，也有的是在给定范围内自行设定的。 中断向量和中断服务程序的对应关系主要是由IDT（中断向量表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符（一共有三类中断门描述符：任务门、中断门和陷阱门），留待CPU查询使用。而IDT本身的位置是由idtr保存的，当然这个地址也是由OS填充的。</p></li><li><p>中断服务程序具体负责处理中断（异常）的代码是由软件，也就是操作系统实现的，这部分代码属于操作系统内核代码。也就是说从CPU检测中断信号到加载中断服务程序以及从中断服务程序中恢复执行被暂停的程序，这个流程基本上是硬件确定下来的，而具体的中断向量和服务程序的对应关系设置和中断服务程序的内容是由操作系统确定的。</p></li></ul><p><strong>(2) CPU检查是否有中断/异常信号</strong></p><p> 　　CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量[2]。</p><p>对于异常和系统调用那样的软中断，因为中断向量是直接给出的，所以和通过IRQ（中断请求）线发送的硬件中断请求不同，不会再专门去取其对应的中断向量。</p><p><strong>(3) 根据中断向量到IDT表中取得处理这个向量的中断程序的段选择符</strong></p><p>　　CPU根据得到的中断向量到IDT表里找到该向量对应的中断描述符，中断描述符里保存着中断服务程序的段选择符。</p><p><strong>(4) 根据取得的段选择符到GDT中找相应的段描述符</strong></p><p>　　CPU使用IDT查到的中断服务程序的段选择符从GDT中取得相应的段描述符，段描述符里保存了中断服务程序的段基址和属性信息，此时CPU就得到了中断服务程序的起始地址。这里，CPU会根据当前cs寄存器里的CPL和GDT的段描述符的DPL，以确保中断服务程序是高于当前程序的，如果这次中断是编程异常（如：int 80h系统调用），那么还要检查CPL和IDT表中中断描述符的DPL，以保证当前程序有权限使用中断服务程序，这可以避免用户应用程序访问特殊的陷阱门和中断门[3]。</p><p><strong>(5) CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址</strong></p><p>　　CPU会根据CPL和中断服务程序段描述符的DPL信息确认是否发生了特权级的转换，比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的首地址存在TR寄存器中）里取得该程序的内核栈地址，即包括ss和esp的值，并立即将系统当前使用的栈切换成新的栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的<strong>ss,esp</strong>压到新栈中保存起来。也就说比如当前在某个函数中，使用的栈，在中断发生时，需要切换新的栈。</p><p><strong>(6) 保护当前程序的现场</strong></p><p>　　CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息。</p><p><strong>(7) 跳转到中断服务程序的第一条指令开始执行</strong></p><p>　　CPU利用中断服务程序的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务程序。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</p><p><strong>(8) 中断服务程序处理完毕，恢复执行先前中断的程序</strong></p><p>　　在每个中断服务程序的最后，必须有中断完成返回先前程序的指令，这就是iret（或iretd）。程序执行这条返回指令时，会从栈里弹出先前保存的被暂停程序的现场信息，<strong>即eflags,cs,eip</strong>重新开始执行。</p><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><p>ucore在lab5中提供用户态进程的创建和执行机制，给应用程序提供一个用户态的运行环境。 </p><h2 id="练习1：加载应用程序并执行（需要编码）"><a href="#练习1：加载应用程序并执行（需要编码）" class="headerlink" title="练习1：加载应用程序并执行（需要编码）"></a>练习1：加载应用程序并执行（需要编码）</h2><blockquote><p>do_execv函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段 等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能 够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。</p></blockquote><p><code>load_icode</code> 先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令<code>iret</code>后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断； </p><p><code>load_icode</code>函数需要填写的部分为：</p><ul><li>将<code>trapframe</code>的代码段寄存器设为用户态的代码段<code>USER_CS</code>；</li><li>将<code>trapframe</code>的数据段、附加段、堆栈段寄存器设为用户态的数据段<code>USER_DS</code>；</li><li>将<code>trapframe</code>的栈顶指针esp设为用户栈的栈顶<code>USTACKTOP</code>；</li><li>将<code>trapframe</code>的代码段寄存器EIP指针设为ELF的入口地址<code>elf-&gt;e_entry</code>；</li><li>将<code>trapframe</code>中EFLAGS设置为使能中断。</li></ul><pre class="line-numbers language-c"><code class="language-c">    tf<span class="token operator">-></span>tf_cs <span class="token operator">=</span> USER_CS<span class="token punctuation">;</span>    tf<span class="token operator">-></span>tf_ds <span class="token operator">=</span> tf<span class="token operator">-></span>tf_es <span class="token operator">=</span> tf<span class="token operator">-></span>tf_ss <span class="token operator">=</span> USER_DS<span class="token punctuation">;</span>    tf<span class="token operator">-></span>tf_esp <span class="token operator">=</span> USTACKTOP<span class="token punctuation">;</span>    tf<span class="token operator">-></span>tf_eip <span class="token operator">=</span> elf<span class="token operator">-></span>e_entry<span class="token punctuation">;</span>    tf<span class="token operator">-></span>tf_eflags <span class="token operator">=</span> FL_IF<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 问题1.1：请在实验报告中描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程 序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态） 到具体执行应用程序第一条指令的整个经过。    </p></blockquote><ul><li><p>在经过调度器占用了CPU的资源之后，用户态进程调用了exec系统调用，从而转入到了系统调用的处理例程；</p></li><li><p>在经过了正常的中断处理例程之后，最终控制权转移到了<code>syscall.c</code>中的<code>syscall</code>函数，然后根据系统调用号转移给了<code>sys_exec</code>函数，在该函数中调用了<code>do_execve</code>函数来完成指定应用程序的加载；</p></li><li><p>在<code>do_execve</code>中进行了若干设置，包括推出当前进程的页表，换用kernel的PDT之后，使用<code>load_icode</code>函数，完成了对整个用户线程内存空间的初始化，包括堆栈的设置以及将ELF可执行文件的加载，之后通过<code>current-&gt;tf</code>指针修改了当前系统调用的<code>trapframe</code>，使得最终中断返回的时候能够切换到用户态，并且同时可以正确地将控制权转移到应用程序的入口处；</p></li><li><p>在完成了<code>do_exec</code>函数之后，进行正常的中断返回的流程，由于中断处理例程的栈上面的<code>eip</code>已经被修改成了应用程序的入口处，而<code>cs</code>上的<code>CPL</code>是用户态，因此<code>iret</code>进行中断返回的时候会将堆栈切换到用户的栈，并且完成特权级的切换，并且跳转到要求的应用程序的入口处；</p></li><li><p>应用程序具体执行的第一条指令由<code>trapframe</code>中<code>eip</code>的值给定。在<code>__trapret</code>返回后即转到新进程中的第一条指令执行。 </p></li></ul><h2 id="练习2：父进程复制自己的内存空间给子进程（需要编码）"><a href="#练习2：父进程复制自己的内存空间给子进程（需要编码）" class="headerlink" title="练习2：父进程复制自己的内存空间给子进程（需要编码）"></a>练习2：父进程复制自己的内存空间给子进程（需要编码）</h2><blockquote><p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合 法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数（位于 kern/mm/pmm.c中）实现的，请补充copy_range的实现，确保能够正确执行。</p></blockquote><p>父进程调用fork系统调用生成子进程的过程： </p><ul><li>父进程调用fork系统调用，进入正常的中断处理机制，最终交由<code>syscall</code>函数进行处理，根据系统调用号，交由<code>sys_fork</code>函数处理，该函数进一步调用了<code>do_fork</code>函数，这个函数的作用是创建子进程，并且将父进程的内存空间复制给子进程；</li></ul><h5 id="do-fork函数与copy-range相关的步骤的具体执行流程"><a href="#do-fork函数与copy-range相关的步骤的具体执行流程" class="headerlink" title="do_fork函数与copy_range相关的步骤的具体执行流程"></a><code>do_fork</code>函数与<code>copy_range</code>相关的步骤的具体执行流程</h5><ul><li>do_fork函数调用copy_mm进行内存空间的复制，在该函数中，进一步调用了dup_mmap，在这个函数中，遍历了父进程的所有合法虚拟内存空间，如果这个页存在，则为子进程对应的同一个地址（但是页目录表是不一样的，因此不是一个内存空间）也申请分配一个物理页，并且将这些空间的内容复制到子进程的内存空间中去，具体进行内存复制的函数就是在本次练习中需要完善的copy_range；</li><li>在copy_range函数中，对需要复制的内存空间按照页为单位从父进程的内存空间复制到子进程的内存空间中去；</li></ul><p>一些用到的函数</p><pre class="line-numbers language-c++"><code class="language-c++">/*   alloc_proc:   create a proc struct and init fields (lab4:exercise1)*   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack*   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags*                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"*   copy_thread:  setup the trapframe on the  process's kernel stack top and*                 setup the kernel entry point and stack of process*   hash_proc:    add proc into proc hash_list*   get_pid:      alloc a unique pid for process*   wakeup_proc:  set proc->state = PROC_RUNNABLE* VARIABLES:*   proc_list:    the process set's list*   nr_process:   the number of process set*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">intdo_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {    int ret = -E_NO_FREE_PROC;    struct proc_struct *proc;    if (nr_process >= MAX_PROCESS) {        goto fork_out;    }    ret = -E_NO_MEM;    if ((proc = alloc_proc()) == NULL)        goto fork_out;    proc->parent = current;    if ((ret = setup_kstack(proc)) != 0)        goto fork_out;    if ((ret = copy_mm(clone_flags, proc)) != 0)        goto fork_out;    copy_thread(proc, stack, tf);    ret = proc->pid = get_pid();    hash_proc(proc);    set_links(proc);    wakeup_proc(proc);fork_out:    return ret;bad_fork_cleanup_kstack:    put_kstack(proc);bad_fork_cleanup_proc:    kfree(proc);    goto fork_out;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="copy-range函数具体执行流程："><a href="#copy-range函数具体执行流程：" class="headerlink" title="copy_range函数具体执行流程："></a><code>copy_range</code>函数具体执行流程：</h5><ul><li>找到父进程指定的某一物理页对应的内核虚拟地址</li><li>找到需要拷贝过去的子进程的对应物理页对应的内核虚拟地址；</li><li>将前者的内容拷贝到后者中去；</li><li>为子进程当前分配这一物理页映射上对应的在子进程虚拟地址空间里的一个虚拟页，为子进程的这个物理页和对应的线性虚拟地址建立映射关系；</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span><span class="token function">copy_range</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>to<span class="token punctuation">,</span> pde_t <span class="token operator">*</span>from<span class="token punctuation">,</span> uintptr_t start<span class="token punctuation">,</span> uintptr_t end<span class="token punctuation">,</span> bool share<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">assert</span><span class="token punctuation">(</span>start <span class="token operator">%</span> PGSIZE <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> end <span class="token operator">%</span> PGSIZE <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">USER_ACCESS</span><span class="token punctuation">(</span>start<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// copy content by page unit.</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//call get_pte to find process A's pte according to the addr start</span>        pte_t <span class="token operator">*</span>ptep <span class="token operator">=</span> <span class="token function">get_pte</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span>nptep<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptep <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            start <span class="token operator">=</span> <span class="token function">ROUNDDOWN</span><span class="token punctuation">(</span>start <span class="token operator">+</span> PTSIZE<span class="token punctuation">,</span> PTSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span> <span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">char</span> <span class="token operator">*</span>src_kvaddr <span class="token operator">=</span> <span class="token function">page2kva</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>       找到父进程需要复制的物理页在内核地址空间中的虚拟地址，这是由于这个函数执行的时候使用的时内核的地址空间            <span class="token keyword">char</span> <span class="token operator">*</span>dst_kvaddr <span class="token operator">=</span> <span class="token function">page2kva</span><span class="token punctuation">(</span>npage<span class="token punctuation">)</span><span class="token punctuation">;</span>      找到子进程需要被填充的物理页的内核虚拟地址            <span class="token function">memcpy</span><span class="token punctuation">(</span>dst_kvaddr<span class="token punctuation">,</span> src_kvaddr<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>  将父进程的物理页的内容复制到子进程中去            <span class="token function">page_insert</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> npage<span class="token punctuation">,</span> start<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>     建立子进程的物理页与虚拟页的映射关系    <span class="token punctuation">}</span>    <span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    start <span class="token operator">+</span><span class="token operator">=</span> PGSIZE<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h5><blockquote><p>请在实验报告中简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。 </p></blockquote><p>“Copy on Write”机制的主要思想是使得进程执行fork系统调用进行复制的时候，父进程不会简单地将整个内存中的内容复制给子进程，而是暂时共享相同的物理内存页；而当其中一个进程需要对内存进行修改的时候，再额外创建一个自己私有的物理内存页，将共享的内容复制过去，然后在自己的内存页中进行修改。</p><p>要实现“Copy on Write机制”，那就需要对几个函数进行一定的修改</p><ul><li>在执行<code>do_fork</code>时，子进程的页目录表直接拷贝父进程的页目录表，而不是拷贝内核页目录表；在<code>dup_mmap</code>函数中，<code>copy_range</code>函数为子进程分配物理内存,而是将子进程和父进程的虚拟页映射上同一个物理页面，然后在分别在这两个进程的虚拟页对应的PTE部分将这个页置成是不可写的<br>首先在vmm.c中将dup_mmap中的share变量的值改为1，启用共享：<pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">dup_mmap</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>to<span class="token punctuation">,</span> <span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>from<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  bool share <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>在<code>pmm.c</code>中为<code>copy_range</code>添加对共享的处理，如果<code>share</code>条件变量为1，那么将子进程的页面映射到父进程的页面。<br>同时利用PTE中的保留位将这个页设置成共享的页面，如果应用程序试图写某一个共享页就会产生页访问异常，交给缺页处理程序进行异常处理，同时将父子进程的页目录表的写权限取消，保持只读的权限。这样一旦父子进程执行写操作时，就会发生页面访问异常，进入页面访问异常处理函数中，再进行内存拷贝操作，并恢复页目录表的写权限。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">copy_range</span><span class="token punctuation">(</span>pde_t <span class="token operator">*</span>to<span class="token punctuation">,</span> pde_t <span class="token operator">*</span>from<span class="token punctuation">,</span> uintptr_t start<span class="token punctuation">,</span> uintptr_t end<span class="token punctuation">,</span> bool share<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptep <span class="token operator">&amp;</span> PTE_P<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>nptep <span class="token operator">=</span> <span class="token function">get_pte</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> start<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span>E_NO_MEM<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        uint32_t perm <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptep <span class="token operator">&amp;</span> PTE_USER<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//get page from ptep</span>        <span class="token keyword">struct</span> Page <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">pte2page</span><span class="token punctuation">(</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">assert</span><span class="token punctuation">(</span>page<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>share<span class="token punctuation">)</span> <span class="token punctuation">{</span>                这一步保证子进程与父进程对于这个共享页面都保持只读            <span class="token function">page_insert</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> page<span class="token punctuation">,</span> start<span class="token punctuation">,</span> perm <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ret <span class="token operator">=</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> page<span class="token punctuation">,</span> start<span class="token punctuation">,</span> perm <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_W<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// alloc a page for process B</span>            <span class="token keyword">struct</span> Page <span class="token operator">*</span>npage<span class="token operator">=</span><span class="token function">alloc_page</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">assert</span><span class="token punctuation">(</span>npage<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            uintptr_t src_kvaddr <span class="token operator">=</span> <span class="token function">page2kva</span><span class="token punctuation">(</span>page<span class="token punctuation">)</span><span class="token punctuation">;</span>            uintptr_t dst_kvaddr <span class="token operator">=</span> <span class="token function">page2kva</span><span class="token punctuation">(</span>npage<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">memcpy</span><span class="token punctuation">(</span>dst_kvaddr<span class="token punctuation">,</span> src_kvaddr<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>            ret <span class="token operator">=</span> <span class="token function">page_insert</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> npage<span class="token punctuation">,</span> start<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">assert</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>再将父进程的内存空间对应的所有Page结构的ref引用计数均加1，表示子进程也在使用这些内存</p></li><li><p>page fault部分：在page fault的ISR部分，新增加对当前的异常是否由于尝试写了某一个共享页面引起的，如果是的话，额外申请分配一个物理页面，然后将当前的共享页的内容复制过去，建立出错的线性地址与新创建的物理页面的映射关系，将PTE设置设置成非共享的；然后查询原先共享的物理页面是否还是由多个其他进程共享使用的，如果不是的话，就将对应的虚地址的PTE进行修改，删掉共享标记，恢复写标记；这样的话page fault返回之后就可以正常完成对虚拟内存的写操作了；</p></li></ul><h2 id="练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）"><a href="#练习3：阅读分析源代码，理解进程执行-fork-exec-wait-exit-的实现，以及系统调用的实现（不需要编码）" class="headerlink" title="练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）"></a>练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）</h2><p>在执行了系统调用之后，会执行正常的中断处理流程，最终将控制权转移给syscall，之后根据系统调用号执行sys_fork函数，进一步执行了系统调用中实际进行处理的函数</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">do_fork</span><span class="token punctuation">(</span>uint32_t clone_flags<span class="token punctuation">,</span> uintptr_t stack<span class="token punctuation">,</span> <span class="token keyword">struct</span> trapframe <span class="token operator">*</span>tf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">do_exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> error_code<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">do_yield</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">do_execve</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">,</span> size_t len<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>binary<span class="token punctuation">,</span> size_t size<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">do_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>code_store<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">do_kill</span><span class="token punctuation">(</span><span class="token keyword">int</span> pid<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="fork实现："><a href="#fork实现：" class="headerlink" title="fork实现："></a>fork实现：</h3><ul><li><p>实际进行处理的<code>do_fork</code>函数首先检查当前总进程数目是否到达限制，如果到达限制，那么返回<code>E_NO_FREE_PROC</code>；</p></li><li><p>调用<code>alloc_proc</code>来申请一个初始化后的进程控制块；</p></li><li><p>调用<code>setup_kstack</code>为内核进程（线程）建立栈空间；</p></li><li><p>调用<code>copy_mm</code>拷贝或者共享内存空间；</p></li><li><p>调用<code>copy_thread</code>建立trapframe以及进程上下文；</p></li><li><p>调用<code>get_pid()</code>为进程分配一个PID；</p></li><li><p>调用<code>hash_proc(proc)</code>和<code>set_links(proc);将进程控制块</code>PCB`加入哈希表和放入可执行队列链表中</p></li></ul><ul><li>调用<code>wakeup_proc</code>将进程的状态设置为<code>runnable</code>，这样的话在之后就有可能由调度器将子进程运行起来了</li></ul><pre class="line-numbers language-c++"><code class="language-c++">intdo_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {    int ret = -E_NO_FREE_PROC;    struct proc_struct *proc;    if (nr_process >= MAX_PROCESS) {        goto fork_out;    }    ret = -E_NO_MEM;    *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)    *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack    *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags    *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"    *   copy_thread:  setup the trapframe on the  process's kernel stack top and    *                 setup the kernel entry point and stack of process    *   hash_proc:    add proc into proc hash_list    *   get_pid:      alloc a unique pid for process    *   wakeup_proc:  set proc->state = PROC_RUNNABLE    * VARIABLES:    *   proc_list:    the process set's list    *   nr_process:   the number of process set    */    //    1. call alloc_proc to allocate a proc_struct    //    2. call setup_kstack to allocate a kernel stack for child process    //    3. call copy_mm to dup OR share mm according clone_flag    //    4. call copy_thread to setup tf & context in proc_struct    //    5. insert proc_struct into hash_list && proc_list    //    6. call wakeup_proc to make the new child process RUNNABLE    //    7. set ret vaule using child proc's pid    if ((proc = alloc_proc()) == NULL)        goto fork_out;    proc->parent = current;    if ((ret = setup_kstack(proc)) != 0)        goto fork_out;    if ((ret = copy_mm(clone_flags, proc)) != 0)        goto fork_out;    copy_thread(proc, stack, tf);    ret = proc->pid = get_pid();    hash_proc(proc);    set_links(proc);    wakeup_proc(proc);fork_out:    return ret;bad_fork_cleanup_kstack:    put_kstack(proc);bad_fork_cleanup_proc:    kfree(proc);    goto fork_out;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exec实现："><a href="#exec实现：" class="headerlink" title="exec实现："></a>exec实现：</h3><ul><li>实际进行处理的<code>do_execve</code>函数检查进程名称的地址和长度是否合法，如果合法，那么将名称暂时保存在函数栈中；<ul><li>原先的内存内容不再需要，将原来进程的内存全部释放</li></ul></li></ul><pre class="line-numbers language-c++"><code class="language-c++"> if (mm != NULL) {        lcr3(boot_cr3);        if (mm_count_dec(mm) == 0) {            exit_mmap(mm);            put_pgdir(mm);            mm_destroy(mm);        }        current->mm = NULL;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>调用<code>load_icode</code>将要执行的进程代码加载进内存，建立用户态内存空间，同时设置好中断帧，就像是我们在练习一中所完成的那样，使得在最终<code>do_execve</code>函数调用中断返回之后可以跳转到指定的应用程序的入口处。而如果发生加载错误，进行对应的报错处理</li></ul><pre class="line-numbers language-c++"><code class="language-c++">    if ((ret = load_icode(binary, size)) != 0) {        goto execve_exit;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>调用<code>set_proc_name</code>设置进程名称。</li></ul><pre class="line-numbers language-c++"><code class="language-c++">intdo_execve(const char *name, size_t len, unsigned char *binary, size_t size) {    struct mm_struct *mm = current->mm;    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {        return -E_INVAL;    }    if (len > PROC_NAME_LEN) {        len = PROC_NAME_LEN;    }    char local_name[PROC_NAME_LEN + 1];    memset(local_name, 0, sizeof(local_name));    memcpy(local_name, name, len);    if (mm != NULL) {        lcr3(boot_cr3);        if (mm_count_dec(mm) == 0) {            exit_mmap(mm);            put_pgdir(mm);            mm_destroy(mm);        }        current->mm = NULL;    }    int ret;    if ((ret = load_icode(binary, size)) != 0) {        goto execve_exit;    }    set_proc_name(current, local_name);    return 0;execve_exit:    do_exit(ret);    panic("already exit: %e.\n", ret);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="wait实现："><a href="#wait实现：" class="headerlink" title="wait实现："></a>wait实现：</h3><ul><li><p>首先检查用于保存返回码的<code>code_store</code>指针地址位于合法的范围内；</p></li><li><p><code>proc = find_proc(pid)</code>根据PID找到需要等待的子进程PCB</p><ul><li>实际进行处理的<code>do_wait</code>函数,传入参数<code>PID</code>如果不等于0，表示找一个进程id号为<code>pid</code>的退出状态的子进程，如果在执行调用过程中发现当前<code>pid</code>号的子进程为<code>PROC_ZOMBIE</code>状态就跳转到<code>found</code>函数历程执行</li></ul></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        根据PID找到需要等待的子进程PCB<span class="token punctuation">,</span>如果没有需要等待的子进程，那么返回`E_BAD_PROC`        proc <span class="token operator">=</span> <span class="token function">find_proc</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>proc <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> proc<span class="token operator">-></span>parent <span class="token operator">==</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            haskid <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>proc<span class="token operator">-></span>state <span class="token operator">==</span> PROC_ZOMBIE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">goto</span> found<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>如果传入的参数pid=0，就可以找当前进程中任意一个处于退出<code>PROC_ZOMBIE</code>状态的子进程,找到就调到<code>found</code>函数历程进行处理</li></ul><pre class="line-numbers language-c++"><code class="language-c++">else {    proc = current->cptr;    for (; proc != NULL; proc = proc->optr) {        haskid = 1;        if (proc->state == PROC_ZOMBIE) {            goto found;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>接下来 <code>if (haskid)</code>判断是否有需要等待的子进程，如果没有直接返回<code>E_BAD_PROC</code>；</p></li><li><p>如果有需要等待的子进程，如果当前子进程的执行状态不为<code>PROC_ZOMBIE</code>，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为<code>PROC_SLEEPING</code>，睡眠状态为<code>WT\_CHILD</code>，即此时在等待子进程退出，调用<code>schedule()</code>函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行</p></li><li><p>在<code>repeat</code>过程中如果此子进程的执行状态为<code>PROC_ZOMBIE</code>，表明此子进程处于退出状态，就可以执行<code>found</code>函数历程，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作</p><ul><li>首先把子进程控制块从两个进程队列<code>proc_list</code>和<code>hash_list</code>中删除</li><li>并且释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，释放了它所占用的所有资源。</li></ul></li></ul><pre class="line-numbers language-c++"><code class="language-c++">intdo_wait(int pid, int *code_store) {    struct mm_struct *mm = current->mm;    if (code_store != NULL) {        if (!user_mem_check(mm, (uintptr_t)code_store, sizeof(int), 1)) {            return -E_INVAL;        }    }    struct proc_struct *proc;    bool intr_flag, haskid;repeat:    haskid = 0;    if (pid != 0) {        根据PID找到需要等待的子进程PCB,如果没有需要等待的子进程，那么返回`E_BAD_PROC`        proc = find_proc(pid);        if (proc != NULL && proc->parent == current) {            haskid = 1;            if (proc->state == PROC_ZOMBIE) {                goto found;            }        }    }    else {        proc = current->cptr;        for (; proc != NULL; proc = proc->optr) {            haskid = 1;            if (proc->state == PROC_ZOMBIE) {                goto found;            }        }    }    if (haskid) {        current->state = PROC_SLEEPING;        current->wait_state = WT_CHILD;        schedule();        if (current->flags & PF_EXITING) {            do_exit(-E_KILLED);        }        goto repeat;    }    return -E_BAD_PROC;found:    if (proc == idleproc || proc == initproc) {        panic("wait idleproc or initproc.\n");    }    if (code_store != NULL) {        *code_store = proc->exit_code;    }    local_intr_save(intr_flag);    {        unhash_proc(proc);        remove_links(proc);    }    local_intr_restore(intr_flag);    put_kstack(proc);    kfree(proc);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="exit实现："><a href="#exit实现：" class="headerlink" title="exit实现："></a>exit实现：</h3><ul><li>实际进行处理的<code>do_exit</code>函数，首先释放进程的虚拟内存空间；</li></ul><pre class="line-numbers language-c++"><code class="language-c++">if (mm != NULL) {    lcr3(boot_cr3);    if (mm_count_dec(mm) == 0) {        exit_mmap(mm);        put_pgdir(mm);        mm_destroy(mm);    }    current->mm = NULL;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置当前进程状态为<code>PROC_ZOMBIE</code>同时设置返回码为<code>error_code</code>，来表示当前的进程已经不能被调度了，需要父进程来做最后的回收工作，表现为回收此进程的内核栈和进程控制块</li><li>如果当前进程的父进程<code>current-&gt;parent</code>处于等待子进程状态:<code>current-&gt;parent-&gt;wait_state==WT_CHILD</code>，则<code>wakup_proc(current-&gt;parent)</code>唤醒父进程，让父进程帮助自己完成最后的资源回收</li><li>如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程<code>initproc</code>，且各个子进程指针需要插入到<code>initproc</code>的子进程链表中。如果某个子进程的执行状态是PROC_ZOMBIE，则需要唤醒<code>initproc</code>来完成对此子进程的最后回收工作</li><li>主动调用<code>schedule</code>调度函数让出CPU资源进行调度，等待父进程进一步完成其所有资源的回收；</li></ul><pre class="line-numbers language-c++"><code class="language-c++">intdo_exit(int error_code) {    if (current == idleproc) {        panic("idleproc exit.\n");    }    if (current == initproc) {        panic("initproc exit.\n");    }    struct mm_struct *mm = current->mm;    if (mm != NULL) {        lcr3(boot_cr3);        if (mm_count_dec(mm) == 0) {            exit_mmap(mm);            put_pgdir(mm);            mm_destroy(mm);        }        current->mm = NULL;    }    current->state = PROC_ZOMBIE;    current->exit_code = error_code;    bool intr_flag;    struct proc_struct *proc;    local_intr_save(intr_flag);    {        proc = current->parent;        if (proc->wait_state == WT_CHILD) {            wakeup_proc(proc);        }        while (current->cptr != NULL) {            proc = current->cptr;            current->cptr = proc->optr;            proc->yptr = NULL;            if ((proc->optr = initproc->cptr) != NULL) {                initproc->cptr->yptr = proc;            }            proc->parent = initproc;            initproc->cptr = proc;            if (proc->state == PROC_ZOMBIE) {                if (initproc->wait_state == WT_CHILD) {                    wakeup_proc(initproc);                }            }        }    }    local_intr_restore(intr_flag);    schedule();    panic("do_exit will not return!! %d.\n", current->pid);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="问答-1"><a href="#问答-1" class="headerlink" title="问答"></a>问答</h4><blockquote><p>问题3.1: 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p></blockquote><ul><li><code>fork</code>：不会影响当前进程的执行状态，但是会将子进程的状态标记为RUNNALB，在后续CPU进程调度中运行起来；</li><li><code>exec</code>：不会影响当前进程的执行状态，但是会修改当前进程中执行的程序；</li><li><code>wait</code>：取决于是否存在可以释放资源（ZOMBIE）的子进程：<ul><li>有：不会发生状态的改变</li><li>没有：将当前进程置为SLEEPING态，等待执行了<code>exit</code>的子进程将其唤醒</li></ul></li><li><code>exit</code>：会将当前进程的状态修改为ZOMBIE态，并且会将父进程唤醒（修改为RUNNABLE），然后主动让出CPU使用权</li></ul><blockquote><p>问题3.2：请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。</p></blockquote><p>画出执行状态图如下所示：</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715164016.png" alt="用户态进程的执行状态生命周期图"></p>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab03</title>
      <link href="/2020/05/16/ucore-lab03/"/>
      <url>/2020/05/16/ucore-lab03/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab03"><a href="#Ucore-Lab03" class="headerlink" title="Ucore Lab03"></a>Ucore Lab03</h1><h1 id="一、-操作系统原理"><a href="#一、-操作系统原理" class="headerlink" title="一、    操作系统原理"></a>一、    操作系统原理</h1><h2 id="1-1、虚拟内存管理"><a href="#1-1、虚拟内存管理" class="headerlink" title="1.1、虚拟内存管理"></a>1.1、虚拟内存管理</h2><p>​         在实验二的基础上，有了页表的支持，我们可以使得不同用户态运行程序的内存空间之间无法访问，达到对于系统分配资源隔离和保护的作用。而内存地址虚拟化技术也可以用来实现更多的功能：</p><ul><li>内存共享：把两个虚拟地址空间通过页表映射到同一物理地址空间，这只需通过设置不同索引的页表项的内容一致即可，这样如果对两个虚拟页的访问方式是只读方式，这这两个虚拟页可共享页框，节省内存空间；如果CPU对其中之一的虚拟页进行写操作，则这两个虚拟页的数据内容会不同，需要分配一个新的物理页框，并将物理页框标记为可写，这样两个虚拟页面将映射到不同的物理页帧，确保整个内存空间的正确访问。这种技术称为写时复制（Copy on Write）。</li><li>提供超过物理内存大小的虚拟内存空间：这一步需要结合异常中断处理和硬盘来完成。其基本思想是在内存中放置最常用的一些数据，不常用的数据会被放到硬盘上，但给用户态的软件一种感觉，觉得这些数据都在内存中。当用户态软件访问到的数据不在内存中（暂时存放在硬盘上的swap分区上）的时候，这条访存指令会引发异常中断，由操作系统的异常中断处理例程进行管理。这时操作系统会分析引发异常的内存地址，能够把对应缓存在硬盘中的数据重新读入这个内存地址，并让用户态软件重新执行产生访存异常的那条指令。这些由操作系统完成的工作在用户态完全“看”不到，swap分区的出现可以使得在腾出更多的空闲内存空间给经常访问的数据</li><li>按需分配内存：用户态软件在运行时要求操作系统提供很大的内存，操作系统“表面上”表示满足用户需求，但在背后并没有实际分配对应的物理内存空间。而只有在实际访问某虚拟内存地址时，等到用户态软件实际执行对于这些物理内存的访问时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术属于1azy 1oad技术，简称按需分页（demand paging）。在这个过程中由于没有分配对应的物理内存空间，会导致产生访存异常。操作系统的异常中断处理例程发觉这是用户态软件以前确实要求过的内存空间，则在从系统管理的空闲空间中分配一页或几页物理内存给用户态软件，并让用户态软件重新执行产生访存异常的那条指令。这些由操作系统完成的工作在用户态也完全“看”不到。但从操作系统的整体管理的角度看，这种方式在用户态软件确实需要的时候把内存分配给用户态软件，提高了内存的使用率，避免了用户态软件“圈地不用”的现象。</li></ul><p>​         而操作系统在在程序的执行过程中由于某种原因（页框不存在/写只读页等）而使CPU无法最终访问到相应的物理内存单元，即无法完成从虚拟地址到物理地址映射时，CPU会产生一次缺页异常，从而需要进行相应的缺页异常服务例程。而对于这个缺页异常处理的时机就是求调页/页换入换出/写时复制处理的执行时机，当相关处理完成后，缺页异常服务例程会返回到产生异常的指令处重新执行，使得软件可以继续正常运行下去。</p><h2 id="1-2、页面置换算法"><a href="#1-2、页面置换算法" class="headerlink" title="1.2、页面置换算法"></a>1.2、页面置换算法</h2><p>​         操作系统为何要进行页面置换呢？这是由于操作系统给用户态的应用程序提供了一个虚拟的“大容量”内存空间，而实际的物理内存空间又没有那么大。所以操作系统就就“瞒着”应用程序，只把应用程序中“常用”的数据和代码放在物理内存中，而不常用的数据和代码放在了硬盘这样的存储介质上。如果应用程序访问的是“常用”的数据和代码，那么操作系统已经放置在内存中了，不会出现什么问题。但当应用程序访问它认为应该在内存中的的数据或代码时，如果这些数据或代码不在内存中，则根据上一小节的介绍，会产生缺页异常。这时，操作系统必须能够应对这种缺页异常，即尽快把应用程序当前需要的数据或代码放到内存中来，然后重新执行应用程序产生异常的访存指令。如果在把硬盘中对应的数据或代码调入内存前，操作系统发现物理内存已经没有空闲空间了，这时操作系统必须把它认为“不常用”的页换出到磁盘上去，以腾出内存空闲空间给应用程序所需的数据或代码。</p><p>从操作系统原理的角度看，有如下一些页面置换算法：</p><ul><li><p>最优（Optimal）页面置换算法：其所选择的被淘汰页面，将是以后永不使用的或许是在最长的未来时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。但由于操作系统其实无法预知一个应用程序在执行过程中访问到的若干页中，哪一个页是未来最长时间内不再被访问的，因而该算法是无法实际实现，但可以此算法作为上限来评价其它的页面置换算法。</p></li><li><p>先进先出（First In First out，FIFO）页面置换算法：该算法总是淘汰最先进入内存的页，即选择在内存中驻留时间最久的页予以淘汰。只需把一个应用程序在执行过程中已调入内存的页按先后次序链接成一个队列，队列头指向内存中驻留时间最久的页，队列尾指向最近被调入内存的页。这样需要淘汰页时，从队列头很容易查找到需要淘汰的页。FIF0算法只是在应用程序按线性顺序访问地址空间时效果才好，否则效率不高。因为那些常被访问的页，往往在内存中也停留得最久，结果它们因变“老”而不得不被置换出去。FIF0算法的另一个缺点是，它有一种异常现象（Belady现象），即在增加放置页的页帧的情况下，反而使缺页异常次数增多。</p></li><li><p>二次机会（Second Chance）页面置换算法：为了克服FIFO算法的缺点，人们对它进行了改进。此算法在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。<br>当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当需要找到一个页淘汰时，对于最“老”的那个页面，操作系统去检查它的访问位。如果访问位是0，说明这个页面老且无用，应该立刻淘汰出局；如果访问位是1，这说明该页面曾经被访问过，因此就再给它一次机会。具体来说，先把访问位位清零，然后把这个页面放到队列的尾端，并修改它的装入时间，就好像它刚刚进入系统一样，然后继续往下搜索。二次机会算法的实质就是寻找一个比较古老的、而且从上一次缺页异常以来尚未被访问的页面。如果所有的页面都被访问过了，它就退化为纯粹的FIFO算法。</p></li><li><p>LRU（Least Recently Used，LRU）页面置换算法：FIFO置换算法性能之所以较差，是因为它所依据的条件是各个页调入内存的时间，而页调入的先后顺序并不能反映页是否“常用”的使用情况。最近最久未使用（LRU）置换算法，是根据页调入内存后的使用情况进行决策页是否”常用”。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU置换算法是选择最近最久未使用的页予以淘汰。该算法赋予每个页一个访问字段，用来记录一个页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面予以淘汰。</p><p>leetcode上LRU算法实现：hashmap+链表方式予以实现</p><pre class="line-numbers language-c++"><code class="language-c++">class LRUCache {public:    LRUCache(int capacity) {        capacity_ = capacity;    }    int get(int key) {        const auto it = m_.find(key);        // If key does not exist        if (it == m_.cend()) return -1;        // Move this key to the front of the cache        cache_.splice(cache_.begin(), cache_, it->second);        return it->second->second;    }    void put(int key, int value) {                const auto it = m_.find(key);        // Key already exists        if (it != m_.cend()) {            // Update the value            it->second->second = value;            // Move this entry to the front of the cache            cache_.splice(cache_.begin(), cache_, it->second);            return;        }        // Reached the capacity, remove the oldest entry        if (cache_.size() == capacity_) {            const auto& node = cache_.back();            m_.erase(node.first);            cache_.pop_back();        }        // Insert the entry to the front of the cache and update mapping.        cache_.emplace_front(key, value);        m_[key] = cache_.begin();    }private:    int capacity_;    list<pair<int,int>> cache_;    unordered_map<int, list<pair<int,int>>::iterator> m_;};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>时钟（Clock）页面置换算法：也称最近未使用（Not Used Recently，NUR）页面置换算法。虽然二次机会算法是一个较合理的算法，但它经常需要在链表中移动页面，这样做既降低了效率，又是不必要的。一个更好的办法是把各个页面组织成环形链表的形式，类似于一个钟的表面。然后把一个指针指向最古老的那个页面，或者说，最先进来的那个页面。时钟算法和第二次机会算法的功能是完全一样的，只是在具体实现上有所不同。时钟算法需要在页表项（PTE）中设置了一位访问位来表示此页表项对应的页当前是否被访问过。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。然后将内存中所有的页都通过指针链接起来并形成一个循环队列。初始时，设置一个当前指针指向某页（比如最古老的那个页面）。操作系统需要淘汰页时，对当前指针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，把它换出到硬盘上；如针指向的页所对应的页表项进行查询，如果访问位为“0”，则淘汰该页，把它换出到硬盘上；如果访问位为“1”，这将该页表项的此位置“0”，继续访问下一个页。该算法近似地体现了LRU的思想，且易于实现，开销少。但该算法需要硬件支持来设置访问位，且该算法在本质上与FIF0算法是类似的，惟一不同的是在clock算法中跳过了访问位为1的页。</p></li><li><p>改进的时钟（Enhanced Clock）页面置换算法：在时钟置换算法中，淘汰一个页面时只考虑了页面是否被访问过，但在实际情况中，还应考虑被淘汰的页面是否被修改过。因为淘汰修改过的页面还需要写回硬盘，使得其置换代价大于未修改过的页面。改进的时钟置换算法除了考虑页面的访问情况，还需考虑页面的修改情况。即该算法不但希望淘汰的页面是最近未使用的页，而且还希望被淘汰的页是在主存驻留期间其页面内容未被修改过的。这需要为每一页的对应页表项内容中增加一位引用位和一位修改位。当该页被访问时，CPU中的MMU硬件将把访问位置“1”。当该页被“写”时，CPU中的MMU硬件将把修改位置“1”。这样这两位就存在四种可能的组合情况：</p><blockquote><p>（0，0）表示最近未被引用也未被修改，首先选择此页淘汰</p><p>（0，1）最近未被使用，但被修改，其次选择</p><p>（1，0）最近使用而未修改，再次选择</p><p>（1，1）最近使用且修改，最后选择。</p></blockquote></li></ul><p>该算法与时钟算法相比，可进一步减少磁盘的I/0操作次数，但为了查找到一个尽可能适合淘汰的页面，可能需要经过多次扫描，增加了算法本身的执行开销。</p><h2 id="1-3-、可以被换出的页"><a href="#1-3-、可以被换出的页" class="headerlink" title="1.3 、可以被换出的页"></a>1.3 、可以被换出的页</h2><p>​         在操作系统的设计中，一个基本的原则是：并非所有的物理页都可以交换出去的，只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出。这里面的原因是什么呢？操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行过程中，发生了缺页现象，则操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢2~3个数量级），这将导致整个系统运行低效。而且，不难想象，处理缺页过程所用到的内核代码或者数据如果被换出，整个内核都面临崩溃的危险。</p><h2 id="1-4、虚存中的页与硬盘上的扇区之间的映射关系"><a href="#1-4、虚存中的页与硬盘上的扇区之间的映射关系" class="headerlink" title="1.4、虚存中的页与硬盘上的扇区之间的映射关系"></a>1.4、虚存中的页与硬盘上的扇区之间的映射关系</h2><p>​         如果一个页被置换到了硬盘上，那操作系统如何能简捷来表示这种情况呢？在ucore的设计上，充分利用了页表中的PTE来表示这种情况，分为几种情况：</p><p>​         一是当一个PTE用来描述一般意义上的物理页时，显然它应该维护各种权限和映射关系，以及应该有PTE_P标记，表示在内存中，不在硬盘的swap分区</p><p>​         二是当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与swap磁盘上扇区的映射关系，并且该PTE不应该由MMU将它解释成物理页映射（即没有PTE_P标记），与此同时对应的权限则交由mm_struct来维护，当对位于该页的内存地址进行访问的时候，必然导致page fault，触发缺页处理逻辑，根据高24位索引找到此页在硬盘上的起始扇区的位置（其从第几个扇区开始），调入内存之中。然后内核能够根据PTE描述的swap项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好PTE使得内存访问能够继续正常进行。<br>​        如果一个页（4KB/页）被置换到了硬盘某8个扇区（0.5KB/扇区），该PTE的最低位-present位应该为0（没有PTE_P标记），接下来的7位暂时保留，可以用作各种扩展；而原来用来表示页帧号的高24位地址，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。为了在页表项中区别0和swap分区的映射，将swap分区的一个 page空出来不用，也就是说一个高24位不为0，而最低位为0的PTE表示了一个放在硬盘上的页的起始扇区号（见swap.h中对swap_entry_t的描述）：</p><img src=".assets/1589109875641.png" alt="1589109875641" style="zoom:75%;"><p><strong>执行换入换出的时机</strong><br>          check_mm_struct变量这个数据结构表示了目前ucore认为合法的所有虚拟内存空间集合，而mm中的每个vma表示了一段地址连续的合法虚拟空间。当ucore或应用程序访问地址所在的页不在内存时，就会产生Page Fault异常，引起调用do_pgfault函数，此函数会判断产生访问异常的地址属于check_mm_struct某个vma表示的合法虚拟地址空间，且保存在硬盘swap文件中（即对应的PTE的高24位不为0，而最低位为0），则是执行页换入的时机，将调用swap_in_page函数完成页面换入。<br>         换出页面的时机相对复杂一些，针对不同的策略有不同的时机。ucore目前大致有两种策略，即积极换出策略和消极换出策略。积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求；消极换出策略是指，只是当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。</p><h2 id="1-5-错误码errorcode的表示方式"><a href="#1-5-错误码errorcode的表示方式" class="headerlink" title="1.5 错误码errorcode的表示方式"></a>1.5 错误码errorcode的表示方式</h2><p><code>errorcode</code> 的通用定义:</p><p><img src=".assets/v2-771c7e5d0cbb74a928de597d45d5dd8b_720w.jpg" alt="img"></p><p><strong>EXT</strong> External event (<strong>bit 0</strong>),值为 1 时表示硬件外部中断.</p><p><strong>IDT</strong> Descriptor location (<strong>bit 1</strong>), 置为 1 时表示errorcode 的索引部分引用的是 IDT 的一个门描述符,置为 0 时表示引用 GDT 或者当前 LDT 的描述符.</p><p><strong>TI</strong> (<strong>bit 2</strong>)只在 IDT 位为 0 时有用.此时 TI 表示errorcode 的索引部分是 LDT,为 1 是是 GDT.</p><p><strong>注意 Page fault 的错误码比较特殊</strong> ,格式如下：</p><img src=".assets/v2-26998a13109295749485a29757a80a01_720w.jpg" alt="img" style="zoom:75%;"><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><p>​         在实验二中，我们知道目前表示内存中物理页使用情况的变量是基于数据结构Page的全局变量pages数组，pages的每一项表示了计算机系统中一个物理页的使用情况。为了表示物理页可被换出或已被换出的情况，可对Page数据结构进行扩展：</p><p>回顾实验二对于Page结构体的定义：</p><pre class="line-numbers language-c++"><code class="language-c++">struct Page {    int ref;                   //映射此物理页的虚拟页的个数           uint32_t flags;         //物理页属性        unsigned int property;  //连续空页有多少(只在地址最低页有值)    list_entry_t page_link; // 双向链接前驱与后继空闲Page结构的page_link};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Lab3相对于Lab2结构体变为：</p><pre class="line-numbers language-c++"><code class="language-c++">struct Page {    int ref;                        // page frame's reference counter    uint32_t flags;                 // array of flags that describe the status of the page frame    unsigned int property;          // the num of free block, used in first fit pm manager    list_entry_t page_link;         // free list link    list_entry_t pra_page_link;     // used for pra (page replace algorithm)    uintptr_t pra_vaddr;            // used for pra (page replace algorithm)};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>要完成实验需要理解<code>struct Page</code>新增的两个熟悉：</p><p><code>pra_page_link</code>是页替换算法用于组织物理页的链表结构，<code>pra_vaddr</code>表明这个物理页对应哪个虚拟地址。</p><p><code>page_fault</code>函数不知道哪些是“合法”的虚拟页，原因是ucore还缺少一定的数据结构来描述这种不在物理内存中的“合法”虚拟页。为此ucore通过建立<code>mm_struct</code>和<code>vma_struct</code>数据结构，描述了ucore模拟应用程序运行所需的合法内存空间。</p><p>当访问内存产生page fault异常时，可获得访问的内存的方式（读或写）以及具体的虚拟内存地址，这样ucore就可以查询此地址，看是否属于vma_struct数据结构中描述的合法地址范围中，如果在，则可根据访问的权限对页面请求调页/页换入换出处理进行控制（即我们要实现的部分），如果不在，则进行报错处理，于是新增加了两个结构体<code>mm_struct</code>和<code>vma_struct</code>来解决虚拟页合法性描述的问题</p><p>每个进程维护着一个 <code>mm_struct</code>,作为内存描述块的头结点;以此为头节点,每个当前用到的合法的虚拟页都对应一串<code>vma_struct</code>，而<code>vma_struct</code> 链表的作用是描述了虚拟内存的合法性,但实际是否已经分配了物理内存仍然是透明的，每块合法的连续的 page 组成一个 <code>vma</code>.</p><pre class="line-numbers language-c++"><code class="language-c++">struct mm_struct { // 描述一个进程的虚拟地址空间 每个进程的 pcb 中 会有一个指针指向本结构体    list_entry_t mmap_list;        // 链接同一页目录表的虚拟内存空间 的 双向链表的 头节点     struct vma_struct *mmap_cache; // 当前正在使用的虚拟内存空间    pde_t *pgdir;                  // mm_struct 所维护的页表地址(拿来找 PTE)    int map_count;                 // 虚拟内存块的数目    void *sm_priv;                 // 记录访问情况链表头地址(用于置换算法)};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">struct vma_struct { // 虚拟内存空间    struct mm_struct *vm_mm; // 虚拟内存空间属于的进程    uintptr_t vm_start; // 连续地址的虚拟内存空间的起始位置和结束位置    uintptr_t vm_end;    uint32_t vm_flags; // 虚拟内存空间的属性 (读/写/执行)    list_entry_t list_link; // 双向链表 虚拟内存地址按照内存起始位置从小到大将虚拟内存空间链接起来};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>vm_flags</code>的定义在<code>vmm.h</code>中:</p><pre class="line-numbers language-text"><code class="language-text">#define VM_READ   0x00000001  //只读#define VM_WRITE  0x00000002  //可读写#define VM_EXEC   0x00000004  //可执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>考察<code>ma_struct</code></strong></p><h2 id="练习0：-填写已有实验"><a href="#练习0：-填写已有实验" class="headerlink" title="练习0： 填写已有实验"></a>练习0： 填写已有实验</h2><blockquote><p>本实验依赖实验1/2。请把你做的实验1/2的代码填入本实验中代码中有“LAB1”,“LAB2”的注释相应部分。</p></blockquote><p><code>meld lab2/ lab3/</code>转移即可</p><h2 id="练习1-给未被映射的地址映射上物理页（需要编程）"><a href="#练习1-给未被映射的地址映射上物理页（需要编程）" class="headerlink" title="练习1 给未被映射的地址映射上物理页（需要编程）"></a>练习1 给未被映射的地址映射上物理页（需要编程）</h2><blockquote><p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。</p></blockquote><p><strong>页异常</strong>主要由三个原因导致：</p><blockquote><p><strong>1、目标（虚拟）页面不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销）；</strong></p></blockquote><blockquote><p><strong>2、相应的物理页面不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上），此时应该建立映射虚拟页和物理页的映射关系；</strong></p></blockquote><blockquote><p><strong>3、目标访问页的权限不符合（此时页表项P标志=1，比如企图写只读页面）又可以分为读写权限异常与访问权限异常，如用户访问内核区域，此时应该直接报错。</strong> </p></blockquote><blockquote><p><strong>4、超过虚拟内存范围限制越界(非法)，直接报错</strong></p></blockquote><p>下面两个情况简单返回错误即可，前两种情况根据虚拟地址是否映射到物理地址分为两种情况，还没有映射到物理地址的话就分配一个<code>Page</code>然后插入即可了；已经分配了页的虚拟地址然而物理页的内容被别的虚拟地址替换下来了，说明之前有可能通过这个虚拟地址写过这个页，然后换入到了磁盘中，所以需要再分配一个物理页然后从磁盘读入之前的数据到这个物理页。要注意的是要使用<code>do_pgfault</code>这个函数，这个函数直接完成了从获得虚拟页表项，到物理页到虚拟页的映射的过程，并且还执行了FIFO算法中入队的过程。</p><p>所以我们在第一个练习中要实现的逻辑大概就是</p><ul><li><p>通过当前应用程序mm所指向的一级页表，以及虚拟地址，去查询有没有对应的二级页表，如果查询结果为NULL，那么报错，因为没有对应的二级页表项，它根本不存在，也不知道用什么物理页去映射（当然，这里不可能不存在，如果查找到不存在的情况，由于get_pte的create标记位为1，那么会创建一个新的二级页表）；</p></li><li><p>之后，如果是上述新创建的二级页表，那么*ptep就会是0，代表页表项为空，说明没有映射过，此时调用<code>pgdir_alloc_page</code>获取一个物理页，对它进行初始化，同时进行错误检查即可；</p></li><li><p>接下来的else语句就是当需要进行页面替换时候实现页面替换算法，也就是我们第二个练习中需要完成的内容</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptep <span class="token operator">=</span> <span class="token function">get_pte</span><span class="token punctuation">(</span>mm<span class="token operator">-></span>pgdir<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token keyword">goto</span> failed<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>ptep <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">struct</span> Page <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token function">pgdir_alloc_page</span><span class="token punctuation">(</span>mm<span class="token operator">-></span>pgdir<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>page <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token keyword">goto</span> failed<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意要使用<code>pgdir_alloc_page</code>这个函数，这个函数在</p><h3 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h3><blockquote><p>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</p></blockquote><p>可以使用页目录项（Page Directory Entry）和页表项（Page Table Entry）中的最后8位保留位来表示页替换算法所需要的信息</p><p>比如表项中<code>PTE_A</code>表示内存页是否被访问过，<code>PTE_D</code>表示内存页是否被修改过，借助着两位标志位可以实现扩展时钟页面置换算法。</p><blockquote><p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情</p></blockquote><p> 首先罗列出的就是产生页访问异常的几大常见的原因：</p><ul><li>目标页帧不存在（页表项全为0，即该线性地址与物理地址尚未建立映射或者已经撤销)；</li><li>相应的物理页帧不在内存中（页表项非空，但Present标志位=0，比如在swap分区或磁盘文件上)</li><li>不满足访问权限(此时页表项P标志=1，但低权限的程序试图访问高权限的地址空间，或者有程序试图写只读页面).</li></ul><p><strong>当出现上面情况之一，那么就会产生页面page fault异常。以下是执行流程:</strong></p><ol><li><p>CPU把产生异常的线性地址存储在CR2寄存器中</p><p>其中的CR2寄存器 是<code>Page Fault</code>专用的线性地址寄存器.</p><img src=".assets/1589123732114.png" alt="1589123732114" style="zoom:75%;"></li><li><p>CPU在当前内核栈保存当前被打断的程序现场(EFLAGS，CS，EIP，errorCode)</p></li><li><p>CPU把异常中断号0xE对应的中断服务例程的地址（vectors.S中的标号vector14处）加载到CS和EIP寄存器中，开始执行中断服务例程</p></li><li><p>ucore开始处理异常中断:</p></li><li><p>保存硬件没有保存的寄存器</p></li><li><p>在vectors.S中的标号vector14处先把中断号压入内核栈</p></li><li><p>然后再在trapentry.S中的标号__alltraps处把DS、ES和其他通用寄存器都压栈</p></li><li><p>自此，被打断的程序执行现场（context）被保存在内核栈中</p></li><li><p>trap函数开始中断服务例程的处理流程</p></li></ol><blockquote><p>函数调用的步骤基本是：trap–&gt; trap_dispatch–&gt;pgfault_handler–&gt;do_pgfault</p></blockquote><pre class="line-numbers language-c++"><code class="language-c++">voidtrap(struct trapframe *tf) {    // dispatch based on what type of trap occurred    trap_dispatch(tf);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">trap_dispatch(struct trapframe *tf) {      case T_PGFLT:  //page fault        if ((ret = pgfault_handler(tf)) != 0) {            print_trapframe(tf);            panic("handle pgfault failed. %e\n", ret);        }        break;……  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>trap_dispatch</code>函数传入参数是一个中断指针tf，接下来会对于这个中断指针进行switch进行判断，确认一下在各种中断情况中，它具体是由于什么情况中断的，这里我到的中断原因是T_PGFLT，即页访问错误，那么我们会调用一个函数pgfault_handler函数去进一步处理页访问错误的情况。</p><pre class="line-numbers language-c++"><code class="language-c++">static intpgfault_handler(struct trapframe *tf) {    extern struct mm_struct *check_mm_struct;    print_pgfault(tf);    if (check_mm_struct != NULL) {        return do_pgfault(check_mm_struct, tf->tf_err, rcr2());    }    panic("unhandled page fault.\n");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pgfault_handler</code>函数调用<code>do_pgfault</code>函数进行错误处理，传入三个参数：</p><ul><li><code>mm_struct</code>: 进程内存合法性记录表的头结点</li><li><code>error_code</code>: 错误码,说明了异常的类型</li><li><code>addr</code>: cr2 寄存器中记录的当前要访问的目标线性地址</li></ul><p>那么对于访问页的错误可以主要分为以下三种，分情况进行相对应的处理和报错。接下来，我们讨论对于具体可能出现页访问错误的情况进行一一处理和报错。</p><p>（1）如果是虚拟地址的问题，如虚拟地址的范围超过了限制，或者是虚拟地址无法被查找到，即可以说该地址是不合法的，进行了一次非法访问，那么可以直接报错。</p><pre class="line-numbers language-c++"><code class="language-c++"> intdo_pgfault(struct mm_struct *mm, uint32_t error_code, uintptr_t addr) {  struct vma_struct *vma = find_vma(mm, addr);   if (vma == NULL || vma->vm_start > addr) {        cprintf("not valid addr %x, and  can not find it in vma\n", addr);        goto failed;    }    ... }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">struct vma_struct *find_vma(struct mm_struct *mm, uintptr_t addr) {    struct vma_struct *vma = NULL;    if (mm != NULL) {        vma = mm->mmap_cache;        if (!(vma != NULL && vma->vm_start <= addr && vma->vm_end > addr)) {                bool found = 0;                list_entry_t *list = &(mm->mmap_list), *le = list;                while ((le = list_next(le)) != list) {                    vma = le2vma(le, list_link);                    if (vma->vm_start<=addr && addr < vma->vm_end) {                        found = 1;                        break;                    }                }                if (!found) {                    vma = NULL;                }        }        if (vma != NULL) {            mm->mmap_cache = vma;        }    }    return vma;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>find_vma</code>函数越界返回vma=NULL，报错输出<code>not valid addr %x, and  can not find it in vma\n&quot;, addr</code></p><p>（2）如果是目标访问页的权限不符合，比如对一个只读页进行写操作，或者读了一个不可读的页，那么此时可以直接报错。</p><p>关键步骤是<code>switch (error_code &amp; 3)</code>,对于传入的错误码errorcode 来说，他表示页访问异常的类型，错误码的低3位分别是：</p><ul><li><p>P标志（位0）最低位：表示当前的错误是由于不存在页面（0）引起，还是由于违反访问权限（1）引起。</p></li><li><p>W / R标志（位1）：表示当前错误是由于读操作（0）引起还是还是写操作（1）引起。</p></li></ul><p>因此，和权限相关的判断，只需要对P和W/R，即error_code的最低两位判断即可。</p><img src=".assets/v2-26998a13109295749485a29757a80a01_720w.jpg" alt="img" style="zoom:75%;"><p>我们关注的的逻辑集中在后两位。枚举后两位，可以得到的状态如下.对应附上了处理方式.</p><ul><li><strong>00</strong></li><li>fault 原因: 对一个 “不存在”的地址进行了 读 操作</li><li><strong>01</strong>：</li><li>fault 原因: 对一个 “不存在”的地址进行了 写 操作</li><li><strong>10</strong>：</li><li>fault 原因: 对一个存在的地址进行了 读 操作,但触发了页保护(权限)错误</li><li><strong>11</strong></li><li>fault 原因: 对一个存在的地址进行了 写 操作,但触发了页保护(权限)错误</li></ul><p>​         如果能够顺利通过上述的合法性判断，那么此次虚拟内存访问就被认为是合法的，此时，页访问异常的原因，是由于该合法虚拟页，没有对应物理页的映射导致，因此下一步要建立起这个映射，也就是我们函数中需要实现的部分</p><p>​         <strong>把流程归纳一下，就大致是CPU会把产生异常的线性地址存储在CR2寄存器中，并且把表示页访问异常类型的值（简称页访问异常错误码，errorCode）保存在中断栈中。之后通过上述分析的trap–&gt; trap_dispatch–&gt;pgfault_handler–&gt;do_pgfault调用关系，一步步做出处理。</strong></p><h2 id="练习2：补充完成基于FIFO的页面替换算法（需要编程）"><a href="#练习2：补充完成基于FIFO的页面替换算法（需要编程）" class="headerlink" title="练习2：补充完成基于FIFO的页面替换算法（需要编程）"></a>练习2：补充完成基于FIFO的页面替换算法（需要编程）</h2><p>在<code>do_pgfault()</code>函数中增加以下代码：</p><p><code>swap_init_ok</code>是一个标记位，代表硬盘上的swap交换区初始化成功，可以开始替换的过程了</p><p>如果PTE存在，那么说明这一页已经映射过了但是被保存在磁盘中，需要将这一页内存交换出来：</p><ul><li>调用<code>swap_in</code>将内存页从磁盘中载入内存，因为这边实现的方式是消极换出策略，只有当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上；</li><li>调用<code>page_insert</code>建立物理地址与线性地址之间的映射；</li><li>同时在物理页中维护其对应到的虚拟页的信息，方便交换出内存时将正确的内存数据保存在正确的磁盘位置；</li><li>设置当前的物理页为可交换的，调用<code>swap_map_swappable</code>将物理页框加入FIFO队列中，链表头是最早进入内存的节点，链表尾部是最近进入内存的节点，方便进行先进先出的页面替换算法。</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">else</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>swap_init_ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">struct</span> Page <span class="token operator">*</span>page <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">=</span> <span class="token function">swap_in</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>page<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"do_pgfault failed: swap_in failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">goto</span> failed<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">page_insert</span><span class="token punctuation">(</span>mm<span class="token operator">-></span>pgdir<span class="token punctuation">,</span> page<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span>        page<span class="token operator">-></span>pra_vaddr <span class="token operator">=</span> addr<span class="token punctuation">;</span>         <span class="token function">swap_map_swappable</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> page<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token function">cprintf</span><span class="token punctuation">(</span><span class="token string">"no swap_init_ok but ptep is %x, failed\n"</span><span class="token punctuation">,</span><span class="token operator">*</span>ptep<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">goto</span> failed<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p> 在执行缺页换入的FIFO算法时，在kern/mm/swap_fifo.c中，修改_fifo_map_swappable()函数和_fifo_swap_out_victim()函数：</p></blockquote><p>首先查看fifo页面初始化函数：</p><pre class="line-numbers language-c++"><code class="language-c++">static int_fifo_init_mm(struct mm_struct *mm){          list_init(&pra_list_head);     mm->sm_priv = &pra_list_head;     //cprintf(" mm->sm_priv %x in fifo_init_mm\n",mm->sm_priv);     return 0;}static inline voidlist_init(list_entry_t *elm) {    elm->prev = elm->next = elm;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>那么当页面初始化时候<code>head-&gt;next</code>跟<code>head-&gt;prev</code>指向的都是head节点自己，这样头节点既是头结点又是尾节点，由于FIFO基于双向链表实现，所以只需要将元素插入到头节点跟上一次访问的物理页之间，  <code>list_add_before(head, entry)</code>保证了<code>head-&gt;next</code>永远指向的是最早访问的页面，而<code>head-&gt;prev</code>则永远指向最近访问的一个页面</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span><span class="token function">_fifo_map_swappable</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> uintptr_t addr<span class="token punctuation">,</span> <span class="token keyword">struct</span> Page <span class="token operator">*</span>page<span class="token punctuation">,</span> <span class="token keyword">int</span> swap_in<span class="token punctuation">)</span><span class="token punctuation">{</span>    list_entry_t <span class="token operator">*</span>head<span class="token operator">=</span><span class="token punctuation">(</span>list_entry_t<span class="token operator">*</span><span class="token punctuation">)</span> mm<span class="token operator">-></span>sm_priv<span class="token punctuation">;</span>    list_entry_t <span class="token operator">*</span>entry<span class="token operator">=</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>page<span class="token operator">-></span>pra_page_link<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">assert</span><span class="token punctuation">(</span>entry <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//record the page access situlation</span>    <span class="token comment" spellcheck="true">/*LAB3 EXERCISE 2: YOUR CODE*/</span>     <span class="token comment" spellcheck="true">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span>    <span class="token comment" spellcheck="true">//head->prev always points to the the most recent arrival page at the back of the pra_list_head qeueue</span>    <span class="token comment" spellcheck="true">//head->next always points to the the least recent arrival page at the front of the pra_list_head qeueue</span>    <span class="token function">list_add_before</span><span class="token punctuation">(</span>head<span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将双向链表中头部节点后面的第一个节点删除，返回最早访问的页表项在内核空间中对应的页地址（虚拟地址）。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">_fifo_swap_out_victim</span><span class="token punctuation">(</span><span class="token keyword">struct</span> mm_struct <span class="token operator">*</span>mm<span class="token punctuation">,</span> <span class="token keyword">struct</span> Page <span class="token operator">*</span><span class="token operator">*</span> ptr_page<span class="token punctuation">,</span> <span class="token keyword">int</span> in_tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>     list_entry_t <span class="token operator">*</span>head<span class="token operator">=</span><span class="token punctuation">(</span>list_entry_t<span class="token operator">*</span><span class="token punctuation">)</span> mm<span class="token operator">-></span>sm_priv<span class="token punctuation">;</span>         <span class="token function">assert</span><span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">assert</span><span class="token punctuation">(</span>in_tick<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     list_entry_t <span class="token operator">*</span>first <span class="token operator">=</span> <span class="token function">list_next</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">list_del</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token operator">*</span>ptr_page <span class="token operator">=</span> <span class="token function">le2page</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> pra_page_link<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="问答-1"><a href="#问答-1" class="headerlink" title="问答"></a>问答</h3><blockquote><p> 如果要在ucore上实现”extended clock页替换算法”请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题：</p></blockquote><blockquote><p> 1、需要被换出的页的特征是什么？</p></blockquote><p> 基本原则：只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出</p><p>现有的swap_manager框架足以支持在ucore中实现此算法。在练习1已经回答了PTE的组成,在mmu.h通过宏定义的方式定义了PTE组成，其中包括脏位和访问位，因此我们可以根据这两位知道虚拟页是否被访问过以及是否被写过，之后将FIFO的队列式链表改造成环形循环列表，原来的初始化函数不需要改，维护链表的函数_fifo_map_swappable函数需要进行小修改，令每次加入新结点后不仅将其加在最后一个链表项后面，而且要将其指针指向head，形成环形循环链表。</p><p>现需要对swap_out_victim进行显著改变：</p><p> 总是从当前指针开始，对循环链表逐一扫描，通过判断每个链表项所指的物理页状态来决定进行何种操作，其中通过&lt;access,dirty&gt;来表示当前物理页的状态</p><ul><li>如果状态是(0, 0)，说明当前数据无效且没有被修改，只需将该物理页面从链表上去除，该物理页面记为换出页面，且不需要将其写入swap分区；</li><li>如果状态是(1, 0), 将该物理页对应的虚拟页的PTE中的访问位都置成0，然后指针跳转到下一个物理页面；</li><li>如果状态是(0, 1)，则将该物理页对应的虚拟页的PTE中的dirty位改成0，并且将该物理页写入到外存中，然后指针跳转到下一个物理页；</li><li>如果状态是(1, 1)，则该物理页的所有对应虚拟页的PTE中的访问为置成0，然后指针跳转到下一个物理页面；<br>基于此即可实现简单的时钟页替换算法</li></ul><blockquote><p>2、在ucore中如何判断具有这样特征的页？</p></blockquote><p>当内存页被访问后，MMU将在对应的页表项的<code>PTE_A</code>这一位设为1；</p><p>当内存页被修改后，MMU将在对应的页表项的<code>PTE_D</code>这一位设为1</p><blockquote><p>3、何时进行换入和换出操作？</p></blockquote><p> 当需要调用的页不在页表中时，并且在页表已满或者内存已满的情况下，会引发PageFault，此时需要进行换入和换出操作<strong>。</strong>具体是当保存在磁盘中的内存需要被访问时，需要进行换入操作；当位于物理页框中的内存被页面替换算法选择时，需要进行换出操作。 </p>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ucore Lab01</title>
      <link href="/2020/05/16/ucore-lab01/"/>
      <url>/2020/05/16/ucore-lab01/</url>
      
        <content type="html"><![CDATA[<h1 id="Ucore-Lab01"><a href="#Ucore-Lab01" class="headerlink" title="Ucore Lab01"></a>Ucore Lab01</h1><h1 id="一、操作系统原理"><a href="#一、操作系统原理" class="headerlink" title="一、操作系统原理"></a>一、操作系统原理</h1><h2 id="1-1、Makefile文件与gcc的执行过程"><a href="#1-1、Makefile文件与gcc的执行过程" class="headerlink" title="1.1、Makefile文件与gcc的执行过程"></a>1.1、Makefile文件与gcc的执行过程</h2><p>​        使用gcc由C语言源代码文件生成可执行文件的过程要经历四个相互关联的步骤∶预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编(Assembly)和连接(Linking)。命令gcc首先调用cpp进行预处理，在预处理过程中，对源代码文件中的文件包含(include)、预编译语句(如宏定义define等)进行分析。接着调用cc1进行编译，这个阶段根据输入文件生成以.o为后缀的目标文件。汇编过程是针对汇编语言的步骤，调用as进行工作，一般来讲，.S为后缀的汇编语言源代码文件和汇编、.s为后缀的汇编语言文件经过预编译和汇编之后都生成以.o为后缀的目标文件。当所有的目标文件都生成之后，gcc就调用ld来完成最后的关键性工作，这个阶段就是连接。在连接阶段，所有的目标文件被安排在可执行程序中的恰当的位置，同时，该程序所调用到的库函数也从各自所在的档案库中连到合适的地方。</p><blockquote><p>1.预处理，生成预编译文件（.文件）：</p><p> gcc –E hello.c –o hello.i</p><p>2.编译，生成汇编代码（.s文件）：</p><p> gcc –S hello.i –o hello.s</p><p>3.汇编，生成目标文件（.o文件）：</p><p> gcc –c hello.s –o hello.o</p><p>4.链接，生成可执行文件：</p><p> gcc hello.o –o hello</p></blockquote><p>​         在成功编译之后，就进入了链接阶段。在这里涉及到一个重要的概念：函数库。系统把这些函数实现都被做到名为libc.so.6的库文件中去了，在没有特别指定时，Gcc会到系统默认的搜索路径”/usr/lib”下进行查找，也就是链接到libc.so.6库函数中去，这样就能实现函数”printf”了，而这也就是链接的作用。</p><p>​        函数库一般分为静态库和动态库两种。静态库是指编译链接时，把库文件的代码全部加入到可执行文件中，因此生成的文件比较大，但在运行时也就不再需要库文件了。其后缀名一般为“.a”。动态库与之相反，在编译链接时并没有把库文件的代码加入到可执行文件中，而是在程序执行时由运行时链接文件加载库，这样可以节省系统的开销。动态库一般后缀名为“.so”，如前面所述的libc.so.6就是动态库。Gcc在编译时默认使用动态库。</p><p>​        一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为makefile就像一个Shell脚本一样，其中也可以执行操作系统的命令。</p><p>​        makefile带来的好处就是——“自动化编译”，一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。make是一个命令工具，是一个解释makefile中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。可见，makefile都成为了一种在工程方面的编译方法。</p><p>​        对于makefile的规则讲解:<a href="https://blog.csdn.net/Ada_baby/article/details/51283323" target="_blank" rel="noopener">https://blog.csdn.net/Ada_baby/article/details/51283323</a> </p><h2 id="1-2-实模式跟保护模式，为何开启A20，以及如何开启A20"><a href="#1-2-实模式跟保护模式，为何开启A20，以及如何开启A20" class="headerlink" title="1.2. 实模式跟保护模式，为何开启A20，以及如何开启A20"></a>1.2. 实模式跟保护模式，为何开启A20，以及如何开启A20</h2><pre><code>     80386的实模式是为了与8086处理器兼容而设置的。 在实模式下， 80386处理器就相当于一个快速的8086处理器。 80386处理器被复位或加电的时候以实模式启动。 这时候处理器中的各寄存器以实模式的初始化值工作。 80386处理器在实模式下的存储器寻址方式和8086基本一致， 由段寄存器的内容乘以16作为基地址， 加上段内的偏移地址形成最终的物理地址， 这时候它的32位地址线只使用了低20位， 即可访问1MB的物理地址空间。 在实模式下， 80386处理器不能对内存进行分页机制的管理， 所以指令寻址的地址就是内存中实际的物理地址。 在实模式下， 所有的段都是可以读、 写和执行的。 实模式下80386不支持优先级， 所有的指令相当于工作在特权级（ 即优先级0） ， 所以它可以执行所有特权指令， 包括读写控制寄存器CR0等。 这实际上使得在实模式下不太可能设计一个有保护能力的操作系统。 实模式下不支持硬件上的多任务切换。 实模式下的中断处理方式和8086处理器相同， 也用中断向量表来定位中断服务程序地址。 中断向量表的结构也和8086处理器一样， 每4个字节组成一个中断向量， 其中包括两个字节的段地址和两个字节的偏移地址。 应用程序可以任意修改中断向量表的内容， 使得计算机系统容易受到病毒、 木马等的攻击， 整个计算机系统的安全性无法得到保证。</code></pre><p>​        Intel早期的8086 CPU提供了20根地址线,可寻址空间范围即0<del>$2^{20}$(00000H</del>FFFFFH)的 1MB内存空间。 但8086的数据处理位为16位,无法直接寻址1MB内存空间， 所以8086提供了段地址加偏移地址的地址转换机制， 就是我们常见的”段地址(16位):偏移地址(16位或有效地址)”,实际的计算方法为:”段地址*0x10H+偏移地址”， 作为段地址的数据是放在段寄存器中的(16位)， 而作为位偏移地址的数据则是通过8086提供的寻址方式来计算而来的(16位)。 而“段值： 偏移”这种表示法能够表示的最大内存为0x10FFEEH(即0xFFFF0H + 0xFFFFH)， 所以当寻址到超过1MB的内存时， 会发生”回卷”(不会发生异常)。但下一代的基于Intel 80286 CPU的PC AT计算机系统提供了24根地址线，<br>​        这样CPU的寻址范围变为 $2^{24}$=16M,同时也提供了保护模式， 可以访问到1MB以上的内存了， 此时如果遇到“寻址超过1MB”的情况， 系统不会再“回卷”了， 这就造成了向下不兼容。 为了保持完全的向下兼容性， IBM决定在PC AT计算机系统上加个硬件逻辑， 来模仿以上的回绕特征。 他们的方法就是把A20地址线控制和键盘控制器的一个输出进行AND操作， 这样来控制A20地址线的打开（ 使能） 和关闭（ 屏蔽\禁止） 。 一开始时A20地址线控制是被屏蔽的（ 总为0） ， 直到系统软件通过一定的I/O操作去打开它.<br>​        当A20 地址线控制禁止时， 则程序就像在8086中运行， 1MB以上的地是不可访问的。 在保护模式下A20地址线控制是要打开的。 为了使能所有地址位的寻址能力,必须向键盘控制器8042发送一个命令。 键盘控制器8042将会将它的的某个输出引脚的输出置高电平,作为 A20 地址线控制的输入。 一旦设置成功之后,内存将不会再被绕回(memory wrapping),这样我们就可以寻址intel 80286CPU支持的16M 内存空间， 或者是寻址intel 80386 以上级别CPU支持的所有 4G内存空间了。<br>​        8042键盘控制器的I/O端口是0x60～ 0x6f， 实际上IBM PC/AT使用的只有0x60和0x64两个端口（ 0x61、 0x62和0x63用于与XT兼容目的） 。 8042通过这些端口给键盘控制器或键盘发送命令或读取状态。 输出端口P2用于特定目的。 位0（ P20引脚） 用于实现CPU复位操作， 位1（ P21引脚） 用户控制A20信号线的开启与否。 系统向输入缓冲（ 端口0x64） 写入一个字节， 即发送一个键盘控制器命令。 可以带一个参数。 参数是通过0x60端口发送的。 命令的返回值也从端口 0x60去读。<br>​        在bootasm.S中， “seta20.1”标号和“seta20.2”标号后的汇编代码即是用来完成A20地址线控制打开工作的。  </p><h2 id="1-3-基于分段模式的访存指令解析"><a href="#1-3-基于分段模式的访存指令解析" class="headerlink" title="1.3.基于分段模式的访存指令解析"></a>1.3.基于分段模式的访存指令解析</h2><p> 当CPU执行一条访存指令时,基于分段模式的具体硬件操作过程如下：</p><ol><li>根据指令的内容确定应该使用的段寄存器， 比如取内存指令的内存地址所对应的数据段寄存器为DS；</li><li>根据段寄存器DS的值作为选择子， 以此选择子值为索引， 在段描述符表（ 可理解为一个大数组）找到索引指向的段描述符（ 可理解为数组中的元素） ；</li><li>在段描述符中取出基地址域（ 段的起始地址） 和地址范围域（ 段的长度） 的值；</li><li>将指令内容确定的地址偏移， 与地址范围域的值比较， 确保地址偏移小于地址范围， 这样是为了确保地址范围不会跨出段的范围； （ 第一层保护）</li><li>根据指令的性质（ 当前指令的CS值的低两位） 确定当前指令的特权级， 需要高于当前指令访问的数据段的特权级； （ 第二层保护） ；</li><li>根据指令的性质(指令是做读还是写操作)， 需要当前指令访问的数据段可读或可写； （ 第三层保护）</li><li>将DS指向的段描述符中基地址域的值加上指令内容中指定的访存地址段内偏移值， 形成实际的物理地址（ 实现地址转换）， 发到数据地址总线上， 到物理内存中寻址， 并取回该地址对应的数据内容。</li><li>分段机制涉及4个关键内容： 逻辑地址（ Logical Address,应用程序员看到的地址， 在操作系统原理上称为虚拟地址， 以后提到虚拟地址就是指逻辑地址） 、 物理地址（ Physical Address, 实际的物理内存地址） 、 段描述符表（ 包含多个段描述符的“数组”） 、 段描述符（ 描述段的属性， 及段描述符表这个“数组”中的“数组元素”） 、 段选择子（ 即段寄存器中的值， 用于定位段描述符表中段描述符表项的索引） 。</li></ol><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172537.png" alt="1586680530721" style="zoom:75%;"><h2 id="1-4-段描述符与段描述符表"><a href="#1-4-段描述符与段描述符表" class="headerlink" title="1.4.段描述符与段描述符表"></a>1.4.段描述符与段描述符表</h2><h3 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h3><p>​        在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes)。在ucore中的kern/mm/mmu.h中的struct segdesc 数据结构中有具体的定义</p><pre class="line-numbers language-c++"><code class="language-c++">/* segment descriptors */struct segdesc {    段界限：规定段的大小。在80386保护模式下，段界限用20位表示，而且段界限可以是以字节为单位或以4K字节为单位。    unsigned sd_lim_15_0 : 16;        // low bits of segment limit    段基地址： 即线性地址空间中段的起始地址。 在80386保护模式下， 段基地址长32位。 因为基地址长度与寻址地址的长度相同， 所以任何一个段都可以从32位线性地址空间中的任何一个字节开始， 而不像实方式下规定的边界必须被16整除。 在实验    中， 一般都简化了段机制的使用， 把所有段的段基地址设置为0。    unsigned sd_base_15_0 : 16;        // low bits of segment base address    unsigned sd_base_23_16 : 8;        // middle bits of segment base address    用于区别不同类型的描述符。 可表示所描述的段是代码段还是数据段， 所描述的段是否可读/写/执行,段的扩展方向等    unsigned sd_type : 4;            // segment type (see STS_ constants)    unsigned sd_s : 1;                // 0 = system, 1 = application    描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。    unsigned sd_dpl : 2;            // descriptor Privilege Level    unsigned sd_p : 1;                // present    unsigned sd_lim_19_16 : 4;        // high bits of segment limit    unsigned sd_avl : 1;            // unused (available for software use)    unsigned sd_rsv1 : 1;            // reserved    unsigned sd_db : 1;                // 0 = 16-bit segment, 1 = 32-bit segment    段界限用20位表示， 而且段界限可以是以单字节为最小单位或以4K字节为最小单位。 在实验中， 一般都简化了段机制的使用，     把所有段的段界限设置为0xFFFFF， 以4K字节为最小单位， 即段的界限为4GB；    unsigned sd_g : 1;                // granularity: limit scaled by 4K when set    unsigned sd_base_31_24 : 8;        // high bits of segment base address};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172538.png" alt="1586679194741" style="zoom:75%;"><h3 id="段描述符表"><a href="#段描述符表" class="headerlink" title="段描述符表"></a>段描述符表</h3><p>​        各种各样的用户描述符和系统描述符，都放在对应的全局描述符表、局部描述符表和中断描述符表中。描述符表(即段表)定义了IA32系统的所有段的情况。所有的描述符表本身都占据一个字节为8的倍数的存储器空间，空间大小在8个字节(至少含一个描述符)到64K字节(至多含8K)个描述符之间。</p><ol><li><strong>全局描述符表(GDT)</strong><br>全局描述符表GDT(Global Descriptor Table)，除了任务门，中断门和陷阱门描述符外，包含着系统中所有任务都共用的那些段的描述符。 它的第一个8字节位置没有使用。</li><li><strong>中断描述符表IDT(Interrupt Descriptor Table)</strong><br>中断描述符表IDT(Interrupt Descriptor Table)，包含256个门描述符。IDT中只能包含任务门、中断门和陷阱门描述符，虽然IDT表最长也可以为64K字节，但只能存取2K字节以内的描述符，即256个描述符，这个数字是为了和8086保持兼容。</li><li><strong>局部描述符表(LDT)</strong><br>局部描述符表LDT(local Descriptor Table)，包含了与一个给定任务有关的描述符，每个任务各自有一个的LDT。 有了LDT，就可以使给定任务的代码、 数据与别的任务相隔离。每一个任务的局部描述符表LDT本身也用一个描述符来表示，称为LDT描述符，它包含了有关局部描述符表的信息，被放在全局描述符表GDT中。</li></ol><h2 id="1-5、ELF文件简介"><a href="#1-5、ELF文件简介" class="headerlink" title="1.5、ELF文件简介"></a>1.5、ELF文件简介</h2><p>ELF文件格式是Linux系统下的一种常用目标文件(object file)格式，目标文件有三种类型:</p><ul><li><p>可重定位文件(Relocatable File) .o)包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。</p></li><li><p>可执行文件(Executable File) .exe) 包含适合于执行的一个程序，此文件规定了exec() 如何创建一个程序的进程映像。</p></li><li><p>共享目标文件(Shared Object File) .so) 包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理， 生成另外一个目标文件。其次动态链接器(Dynamic Linker)可能将它与某 个可执行文件以及其它共享目标一起组合，创建进程映像。</p><p>目标文件全部是程序的二进制表示，目的是直接在某种处理器上直接执行。这种ELF文件格式类型提供程序的进程映像，加载程序的内存地址描述</p><p>使用readelf工具的-h选项查看ELF文件头部信息 </p></li></ul><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172539.png" alt="1586700882160" style="zoom:75%;"><p>从中， 我们可以看到kernel的入口点在0x100000， program header相对文件的偏移位置在52， elf header的大小为52字节， program header的大小为32字节  </p><h3 id="程序头部（Program-Header）"><a href="#程序头部（Program-Header）" class="headerlink" title="程序头部（Program Header）"></a>程序头部（Program Header）</h3><p>​         program header描述与程序执行直接相关的目标文件结构信息， 用来在文件中定位各个段的映像，同时包含其他一些用来为程序创建进程映像所必需的信息。 可执行文件的程序前面部分有一个program header结构的数组， 每个结构描述了一个“段”（ segment） 或者准备程序执行所必需的其它信息。 目标文件的 “段”（ segment） 包含一个或者多个 “节区”（ section） ， 也就是“段内容（ Segment Contents） ” 。  </p><p>使用<code>readelf</code>工具的-l选项查看ELF程序头部信息</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172540.png" alt="1586701771944"></p><p> 从中， 我们可以看到kernel的入口点在0x100000， 代码段位于0x00100000， 大小为0x0d1c4； 数据段位于0x10e000， 大小为0x00a16  </p><p>其中各个字段说明：</p><pre class="line-numbers language-c++"><code class="language-c++">p_type 此数组元素描述的段的类型，或者如何解释此数组元素的信息。具体如下图。p_offset 此成员给出从文件头到该段第一个字节的偏移。p_vaddr 此成员给出段的第一个字节将被放到内存中的虚拟地址。p_paddr 此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的。p_filesz 此成员给出段在文件映像中所占的字节数。可以为 0。p_memsz 此成员给出段在内存映像中占用的字节数。可以为 0。p_flags 此成员给出与段相关的标志。p_align 可加载的进程段的 p_vaddr 和 p_offset 取值必须合适，相对于对页面大小的取模而言。此成员给出段在文件中和内存中如何 对齐。数值 0 和 1 表示不需要对齐。否则 p_align 应该是个正整数，并且是 2 的幂次数，p_vaddr 和 p_offset 对 p_align 取模后应该相等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ELF-段表"><a href="#ELF-段表" class="headerlink" title="ELF 段表"></a>ELF 段表</h3><p>ELF文件中有很多段，段表（Section Header Table）就是保存这些段的基本信息的结构，包括了段名、段长度、段在文件中的偏移位置、读写权限和其他段属性。</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172541.png" alt="1586700620547" style="zoom:75%;"><p> 使用<code>readelf</code>可以看到ELF文件全部的段结构 </p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172542.png" alt="1586700698431" style="zoom:75%;"><p> 可以看到一共有11个段，每个段对应一个<code>Section Header</code>数据结构</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172543.png" alt="1586700785837" style="zoom:75%;"><p><strong>BSS段</strong>： BSS（ Block Started by Symbol） 段通常是指用来存放执行程序中未初始化的全局变量的一块存储区域。 BSS段属于静态内存分配的存储空间。<br><strong>数据段</strong>： 数据段（ Data Segment） 通常是指用来存放执行程序中已初始化的全局变量的一块存储区域。 数据段属于静态内存分配的存储空间。<br><strong>代码段</strong>： 代码段（ Code Segment/Text Segment） 通常是指用来存放程序执行代码的一块存储区域。 这部分区域的大小在程序运行前就已经确定， 并且内存区域通常属于只读, 某些CPU架构也允许代码段为可写， 即允许修改程序。 在代码段中， 也有可能包含一些只读的常数变量， 例如字符串常量等。  </p><h2 id="1-6、函数调用栈-剖析＋图解"><a href="#1-6、函数调用栈-剖析＋图解" class="headerlink" title="1.6、函数调用栈 剖析＋图解"></a>1.6、函数调用栈 剖析＋图解</h2><p> <a href="https://blog.csdn.net/wangyezi19930928/article/details/16921927" target="_blank" rel="noopener">https://blog.csdn.net/wangyezi19930928/article/details/16921927</a> +《深入理解计算机系统》</p><pre><code>                                                                                     &lt;img src=&quot;https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172544.gif&quot; alt=&quot;img&quot; style=&quot;zoom:75%;&quot; /&gt; </code></pre><h2 id="1-7、-中断响应的处理流程"><a href="#1-7、-中断响应的处理流程" class="headerlink" title="1.7、 中断响应的处理流程"></a>1.7、 中断响应的处理流程</h2><p>非屏蔽中断和异常的编号是固定的， 而屏蔽中断的编号可以通过对中断控制器的编程来调整。 256个中断的分配如下：</p><p>0<del>31号的中断对应于故障、 陷阱和非屏蔽外设中断。<br>32</del>47号的中断分配给可屏蔽外设中断。<br>48~255号的中断可以用软件来设置，ucore在之后实现中调用其中的一个中断号来实现系统调用。  </p><p>​                                                                                                         <img src="http://www.cppblog.com/images/cppblog_com/aaxron/%E4%B8%AD%E6%96%AD.png" alt="img" style="zoom:75%;"> </p><h3 id="具体的执行流程"><a href="#具体的执行流程" class="headerlink" title="具体的执行流程"></a>具体的执行流程</h3><p><strong>(1) 中断响应的事前准备：</strong></p><p>　　系统要想能够应对各种不同的中断信号，总的来看就是需要知道每种信号应该由哪个中断服务程序负责以及这些中断服务程序具体是如何工作的。系统只有事前对这两件事都知道得很清楚，才能正确地响应各种中断信号和异常。</p><ol><li>系统将所有的中断信号统一进行了编号（一共256个：0～255），这个号称为中断向量，具体哪个中断向量表示哪种中断有的是规定好的，也有的是在给定范围内自行设定的。 中断向量和中断服务程序的对应关系主要是由IDT（中断向量表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符（一共有三类中断门描述符：任务门、中断门和陷阱门），留待CPU查询使用。而IDT本身的位置是由idtr保存的，当然这个地址也是由OS填充的。</li><li>中断服务程序具体负责处理中断（异常）的代码是由软件，也就是操作系统实现的，这部分代码属于操作系统内核代码。也就是说从CPU检测中断信号到加载中断服务程序以及从中断服务程序中恢复执行被暂停的程序，这个流程基本上是硬件确定下来的，而具体的中断向量和服务程序的对应关系设置和中断服务程序的内容是由操作系统确定的。</li></ol><p><strong>(2) CPU检查是否有中断/异常信号</strong></p><p> 　　CPU在执行完当前程序的每一条指令后，都会去确认在执行刚才的指令过程中中断控制器（如：8259A）是否发送中断请求过来，如果有那么CPU就会在相应的时钟脉冲到来时从总线上读取中断请求对应的中断向量[2]。</p><p>对于异常和系统调用那样的软中断，因为中断向量是直接给出的，所以和通过IRQ（中断请求）线发送的硬件中断请求不同，不会再专门去取其对应的中断向量。</p><p><strong>(3) 根据中断向量到IDT表中取得处理这个向量的中断程序的段选择符</strong></p><p>　　CPU根据得到的中断向量到IDT表里找到该向量对应的中断描述符，中断描述符里保存着中断服务程序的段选择符。</p><p><strong>(4) 根据取得的段选择符到GDT中找相应的段描述符</strong></p><p>　　CPU使用IDT查到的中断服务程序的段选择符从GDT中取得相应的段描述符，段描述符里保存了中断服务程序的段基址和属性信息，此时CPU就得到了中断服务程序的起始地址。这里，CPU会根据当前cs寄存器里的CPL和GDT的段描述符的DPL，以确保中断服务程序是高于当前程序的，如果这次中断是编程异常（如：int 80h系统调用），那么还要检查CPL和IDT表中中断描述符的DPL，以保证当前程序有权限使用中断服务程序，这可以避免用户应用程序访问特殊的陷阱门和中断门[3]。</p><p><strong>(5) CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址</strong></p><p>　　CPU会根据CPL和中断服务程序段描述符的DPL信息确认是否发生了特权级的转换，比如当前程序正运行在用户态，而中断程序是运行在内核态的，则意味着发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的首地址存在TR寄存器中）里取得该程序的内核栈地址，即包括ss和esp的值，并立即将系统当前使用的栈切换成新的栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的<strong>ss,esp</strong>压到新栈中保存起来。也就说比如当前在某个函数中，使用的栈，在中断发生时，需要切换新的栈。</p><p><strong>(6) 保护当前程序的现场</strong></p><p>　　CPU开始利用栈保护被暂停执行的程序的现场：依次压入当前程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息。</p><p><strong>(7) 跳转到中断服务程序的第一条指令开始执行</strong></p><p>　　CPU利用中断服务程序的段描述符将其第一条指令的地址加载到cs和eip寄存器中，开始执行中断服务程序。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</p><p><strong>(8) 中断服务程序处理完毕，恢复执行先前中断的程序</strong></p><p>　　在每个中断服务程序的最后，必须有中断完成返回先前程序的指令，这就是iret（或iretd）。程序执行这条返回指令时，会从栈里弹出先前保存的被暂停程序的现场信息，<strong>即eflags,cs,eip</strong>重新开始执行。</p><h1 id="二、-实验过程-问题回答"><a href="#二、-实验过程-问题回答" class="headerlink" title="二、 实验过程+问题回答"></a>二、 实验过程+问题回答</h1><h2 id="练习1：-理解通过make生成执行文件的过程"><a href="#练习1：-理解通过make生成执行文件的过程" class="headerlink" title="练习1： 理解通过make生成执行文件的过程"></a>练习1： 理解通过make生成执行文件的过程</h2><blockquote><p>Q1.1：操作系统镜像文件ucore.img是如何一步一步生成的？</p></blockquote><p>make -V执行一下编译,查看结果</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">dd</span> if<span class="token operator">=</span>/dev/zero of<span class="token operator">=</span>bin/ucore.img count<span class="token operator">=</span>1000010000+0 records <span class="token keyword">in</span>10000+0 records out5120000 bytes <span class="token punctuation">(</span>5.1 MB<span class="token punctuation">)</span> copied, 0.0364371 s, 141 MB/s<span class="token function">dd</span> if<span class="token operator">=</span>bin/bootblock of<span class="token operator">=</span>bin/ucore.img conv<span class="token operator">=</span>notrunc1+0 records <span class="token keyword">in</span>1+0 records out512 bytes <span class="token punctuation">(</span>512 B<span class="token punctuation">)</span> copied, 0.000472762 s, 1.1 MB/s<span class="token function">dd</span> if<span class="token operator">=</span>bin/kernel of<span class="token operator">=</span>bin/ucore.img seek<span class="token operator">=</span>1 conv<span class="token operator">=</span>notrunc146+1 records <span class="token keyword">in</span>146+1 records out74923 bytes <span class="token punctuation">(</span>75 kB<span class="token punctuation">)</span> copied, 0.000597927 s, 125 MB/s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>$(V)dd if=/dev/zero of=$@ count=10000</code> 命令表示从/dev/zero文件中获取10000个block， 由于没指定block的大小，因此每一个block为默认值512字节, 总大小为5000M ,并且均为空字符，并且输出到目标文件ucore.img中,；</p><p> <code>$(V)dd if=$(bootblock) of=$@ conv=notrunc</code> 命令表示从 bin/bootblock 文件中获取数据，并且输出到目标文件 bin/ ucore.img中，-notruct选项表示不要对数据进行删减；</p><p> <code>$(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc</code> 命令表示从bin/kernel文件中获取数据，并且输出到目标文件bin/ucore.img中, 并且seek = 1表示跳过第一个block, 从第2个block也就是第512个字节后面开始拷贝bin/kernel的内容 , 因为ucore.img的第1个block已经用来保存bootblock的内容了。</p><p><strong>在Makefile文件中找到生成ucore.img的代码如下</strong></p><p>发现ucore.img文件的生成依赖于kernel和bootblock</p><pre class="line-numbers language-c++"><code class="language-c++">UCOREIMG := $(call totarget,ucore.img)   //此时通过call函数来实现创建ucore.img的过程，UCOREIMG代表的就是即将生成的ucore.img文件     $(UCOREIMG): $(kernel) $(bootblock)        //这里表示ucore-img文件的生成依赖于kernel 和 bootblock      $(V)dd if=/dev/zero of=$@ count=10000    //为UCOREIMG分配一个10000*512字节大小的空间     $(V)dd if=$(bootblock) of=$@ conv=notrunc  //将bootblock拷贝到UCOREIMG中，大小为512字节     $(V)dd if=$(kernel) of=$@ seek=1 conv=notrunc //将kernel拷贝到UCOREIMG中，从文件开头跳过seek个块之后开始拷贝$(call create_target,ucore.img)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接下来我们查看如何生成kernel和bootblock</p><p><strong>下面是生成kernel的代码：</strong></p><p> 1.设置生成的kernel目标名为bin/kernel </p><pre class="line-numbers language-c++"><code class="language-c++"># create kernel targetkernel = $(call totarget,kernel)totarget = $(addprefix $(BINDIR)$(SLASH),$(1))BINDIR  := binSLASH   := /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 2.<code>$(kernel): tools/kernel.ld</code>指出kernel目标文件需要依赖tools/kernel.ld文件 </p><ol start="3"><li>指出kernel目标文件依赖的obj文件。最终效果为<code>KOBJS=obj/libs/*.o obj/kern/**/*.o</code> </li></ol><pre class="line-numbers language-c++"><code class="language-c++">// //kernel的生成还依赖KOBJS$(kernel): $(KOBJS)KOBJS   = $(call read_packet,kernel libs)read_packet = $(foreach p,$(call packetname,$(1)),$($(p)))packetname = $(if $(1),$(addprefix $(OBJPREFIX),$(1)),$(OBJPREFIX))OBJPREFIX   := __objs_<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>4.链接obj/libs/*和obj/kernel/x有的目标文件，使用tools/kernel.ld做连接器脚本</p><pre class="line-numbers language-c++"><code class="language-c++">V       := @LD      := $(GCCPREFIX)ld$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对应到实际的make命令就是</p><pre class="line-numbers language-bash"><code class="language-bash">+ ld bin/kernelld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/string.o obj/libs/printfmt.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数含义：</p><ol><li><p><code>-m elf_i386</code>：生成32位ELF可执行文件</p></li><li><p><code>-nostdlib</code>：关闭内建库</p></li><li><p><code>-T tools/kernel.ld</code>：使用脚本 <code>toold/kernel.ld</code></p></li><li><p><code>-o bin/kernel *.o</code>：使用一系列的 <code>.o</code> 文件生成 `bin/kernel</p><p>使用objdump工具对kernel目标文件反汇编，以便后续调试 </p></li></ol><pre class="line-numbers language-bash"><code class="language-bash">@<span class="token variable"><span class="token variable">$(</span>OBJDUMP<span class="token variable">)</span></span> -S <span class="token variable">$@</span> <span class="token operator">></span> <span class="token variable"><span class="token variable">$(</span>call asmfile,kernel<span class="token variable">)</span></span>OBJDUMP :<span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>GCCPREFIX<span class="token variable">)</span></span>objdump// GCCPREFIX <span class="token operator">=</span> <span class="token string">'i386-elf-'</span> or <span class="token string">''</span>asmfile <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>call cgtype,<span class="token punctuation">$(</span>call toobj,<span class="token punctuation">$(</span>1<span class="token variable">)</span></span><span class="token punctuation">)</span>,o,asm<span class="token punctuation">)</span>cgtype <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>patsubst %.<span class="token punctuation">$(</span>2<span class="token variable">)</span></span>,%.<span class="token variable"><span class="token variable">$(</span>3<span class="token variable">)</span></span>,<span class="token variable"><span class="token variable">$(</span>1<span class="token variable">)</span></span><span class="token punctuation">)</span>toobj <span class="token operator">=</span> <span class="token variable"><span class="token variable">$(</span>addprefix <span class="token punctuation">$(</span>OBJDIR<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>SLASH<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span><span class="token keyword">if</span> <span class="token punctuation">$(</span>2<span class="token variable">)</span></span>,<span class="token variable"><span class="token variable">$(</span>2<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>SLASH<span class="token variable">)</span></span><span class="token punctuation">)</span>,\        <span class="token variable"><span class="token variable">$(</span>addsuffix .o,<span class="token punctuation">$(</span>basename <span class="token punctuation">$(</span>1<span class="token variable">)</span></span><span class="token punctuation">))</span><span class="token punctuation">)</span>OBJDIR  :<span class="token operator">=</span> objSLASH   :<span class="token operator">=</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>下面是生成bootblock的代码</strong></p><p> 1.<code>bootfiles = $(call listf_cc,boot)</code>，前面已经知道listf_cc函数是过滤出对应目录下的.c和.S文件，因此等同于<code>bootfiles=boot/\*.c boot/\*.S</code> </p><p>2.<code>bootblock = $(call totarget,bootblock)</code>，前面已经知道totarget函数是给输入参数增加前缀”bin/“，因此等同于<code>bootblock=&quot;bin/bootblock&quot;</code> </p><p>3.声明bin/bootblock依赖于obj/boot/*.o 和bin/sign文件。toobj函数的作用是给输入参数增加前缀obj/，并将文件后缀名改为.o</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>bootblock<span class="token variable">)</span></span><span class="token keyword">:</span> <span class="token variable"><span class="token variable">$(</span>call toobj,<span class="token punctuation">$(</span>bootfiles<span class="token variable">)</span></span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token variable"><span class="token variable">$(</span>call totarget,sign<span class="token variable">)</span></span>  <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 4.链接所有.o文件以生成obj/bootblock.o </p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token variable"><span class="token variable">$(</span>V<span class="token variable">)</span></span><span class="token variable"><span class="token variable">$(</span>LD<span class="token variable">)</span></span> <span class="token variable"><span class="token variable">$(</span>LDFLAGS<span class="token variable">)</span></span> -N -e start -Ttext 0x7C00 $^ -o <span class="token variable"><span class="token variable">$(</span>call toobj,bootblock<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.编译sign.c，判断 <code>obj/bootblock.out</code> 大小是否超过510字节,使用bin/sign工具将obj/bootblock.out转换生成bin/bootblock目标文件：@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)，从tools/sign.c代码中可知sign工具其实只做了一件事情：将输入文件拷贝到输出文件，控制输出文件的大小为512字节，并将最后两个字节设置为0x55AA</p><pre class="line-numbers language-c++"><code class="language-c++">@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>对应到实际生成bootload的make<code>log</code>输出中gcc命令就是：</p><pre class="line-numbers language-bash"><code class="language-bash">+ ld bin/bootblock      //根据sign规范生成ld -m    elf_i386 -nostdlib -N -e start -Ttext 0x7C00 obj/boot/bootasm.o obj/boot/bootmain.o -o obj/bootblock.o<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参数含义：</p><ol><li><code>-N</code>：设置代码段和数据段均可读写，并且关闭动态链接</li><li><code>-e start</code>：设置入口点符号为start</li><li><code>-Ttext 0x7c00</code>：设置代码段起始地址为 <code>0x7c00</code></li></ol><blockquote><p>问题1.2：一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p></blockquote><p>查看<code>tools/sign.c</code>文件，</p><pre class="line-numbers language-c++"><code class="language-c++">char buf[512];memset(buf, 0, sizeof(buf));FILE *ifp = fopen(argv[1], "rb");int size = fread(buf, 1, st.st_size, ifp);if (size != st.st_size) {    fprintf(stderr, "read '%s' error, size is %d.\n", argv[1], size);    return -1;}fclose(ifp);buf[510] = 0x55;buf[511] = 0xAA;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 在 <code>tools/sign.c</code>里面  有以下两句 说明 符合规范的硬盘主引导扇区特征是 最后两个字节 为 0x55 0xAA 同时 主引导扇区的大小应为 512 字节   <code>buf[510] = 0x55;buf[511] = 0xAA</code>;</p><h2 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h2><blockquote><p> 问题2.1：从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p></blockquote><pre class="line-numbers language-shell"><code class="language-shell">Makefile文件中定义了debug命令：debug: $(UCOREIMG)        $(V)$(QEMU) -S -s -parallel stdio -hda $< -serial null &        $(V)sleep 2        $(V)$(TERMINAL) -e "gdb -q -tui -x tools/gdbinit"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​       由于BIOS是在实模式下运行的，因此需要在tools/gdbinit里进行相应设置，将其修改为:</p><pre><code>set arch i8086target remote: 1234</code></pre><p>​        之后再执行<code>make debug</code>，就可以使用gdb单步追踪BIOS的指令执行了，具体调试结果如下图所示:</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172545.png" alt="1586737662364"></p><p>​         其中 <strong>CS 为代码段寄存器</strong>，而  <strong>IP 为指令指针寄存器</strong> 。 </p><p>​         在刚初始化的时候，cs，eip寄存器的数值分别被初始化为0xf000, 0xfff0, 即第一个执行的指令位于内存中的0xffff0处，该指令是一条跳转指令，跳转到BIOS的主题代码所在的入口；如图所示，使用GDB进行调试可以很方便地观察指令执行过程中的所有寄存器的数值变化；</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172546.png" alt="1586738795909" style="zoom:75%;"><blockquote><p> Q2.2：在初始化位置0x7c00设置实地址断点,测试断点正常</p></blockquote><p>​         0x7c00是bootloader的入口位置，此时CPU仍然处于实模式下，因此只需要设置实地址断点在0x7c00处即可，此时需要的tools/gdbinit文件如下：</p><pre class="line-numbers language-shell"><code class="language-shell">set arch i8086target remote: 1234b *0x7c00continue<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172547.png" alt="1586587007140" style="zoom:80%;"><blockquote><p> Q2.3：从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p></blockquote><p><code>x /5i $pc</code>：查看当前指令指向的地址的反汇编代码</p><p>​         从0x7c00开始的执行的指令的汇编代码，与<code>bootasm.S</code>的入口处的代码进行比较，发现除了gdb反汇编出来的指令中没有指定位宽w（word）之外，其余内容完全一致；</p><p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172548.png" alt="1586589839759"></p><blockquote><p> Q2.4：自己找一个bootloader或内核中的代码位置，设置断点并进行测试。</p></blockquote><p>​         在本次实验中，选择了在内核中设置断点，由于内核是运行在32位保护模式下的，并且运行是需要符号表信息，使得可以在调试过程中得知具体运行的是哪一行C代码，因此对tools/gdbinit做若干修改如下：</p><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172549.png" alt="1586741305831" style="zoom:75%;"><h2 id="练习3：分析bootloader进入保护模式的过程"><a href="#练习3：分析bootloader进入保护模式的过程" class="headerlink" title="练习3：分析bootloader进入保护模式的过程"></a>练习3：分析bootloader进入保护模式的过程</h2><p>​         BIOS把bootloader从硬盘（ 即是我们刚才生成的ucore.img） 的第一个扇区（ 即是我们刚才生成的bootblock） 读出来并拷贝到内存一个特定的地址0x7c00处， 然后BIOS会跳转到那个地址（ 即CS=0， EIP=0x7c00）继续执行。 至此BIOS的初始化工作做完了， 进一步的工作交给了ucore的bootloader。  </p><pre><code>   从0x7c00开始， bootloader用了21条汇编指令完成了初始化和切换到保护模式的工作。 其具体步骤如下：  </code></pre><h4 id="第一步：屏蔽中断-将各个段寄存器重置"><a href="#第一步：屏蔽中断-将各个段寄存器重置" class="headerlink" title="第一步：屏蔽中断,将各个段寄存器重置"></a>第一步：屏蔽中断,将各个段寄存器重置</h4><p>​      切换的时候当然不希望中断发生，需要使用<code>cli</code>来屏蔽中断,并且将各个段寄存器置0</p><pre><code>cli               # Disable interruptscld               # String operations incrementxorw %ax, %ax     # Segment number zeromovw %ax, %ds     # -&gt; Data Segmentmovw %ax, %es     # -&gt; Extra Segmentmovw %ax, %ss     # -&gt; Stack Segment</code></pre><h4 id="第二步：开启A20"><a href="#第二步：开启A20" class="headerlink" title="第二步：开启A20"></a>第二步：开启A20</h4><p>​         Intel早期的8086 CPU提供了20根地址线，寻址范围就是1MB，但是8086字长为16位，直接使用一个字来表示地址就不够了，所以使用段+偏移地址的方式进行寻址。段+偏移地址的最大寻址范围就是0xFFFF0+0xFFFF=0x10FFEF，这个范围大于1MB，所以如果程序访问了大于1MB的地址空间，就会发生回卷。  但下一代的基于Intel 80286 CPU的PC AT计算机系统提供了24根地址线，这样CPU的寻址范围变为 $2^{24}$=16M,同时也提供了保护模式， 可以访问到1MB以上的内存了， 此时如果遇到“寻址超过1MB”的情况， 系统不会再“回卷”了， 这就造成了向下不兼容。 为了保持完全的向下兼容性， IBM决定在PC AT计算机系统上加个硬件逻辑， 来模仿以上的回绕特征。 他们的方法就是把A20地址线控制和键盘控制器的一个输出进行AND操作， 这样来控制A20地址线的打开（ 使能） 和关闭（ 屏蔽\禁止） 。 一开始时A20地址线控制是被屏蔽的（ 总为0） ， 直到系统软件通过一定的I/O操作去打开它（ 参看bootloader的bootasm.S文件） 。  </p><p>​          但是在保护模式下，我们希望能够正常访问所有的内存地址， 所以需要通过将键盘控制器上的A20线置于高电位，使得全部32条地址线可用。 </p><p>​        由于历史原因，开启A20由键盘控制器”8042” PS/2 Controller负责。A20的开启标志位于PS/2 Controller Output Port的第1位，程序要做的就是修改这一位。8042有两个常用的端口：</p><table><thead><tr><th>端口</th><th>访问方式</th><th>功能</th></tr></thead><tbody><tr><td>0x60</td><td>读/写</td><td>数据端口</td></tr><tr><td>0x64</td><td>读</td><td>状态寄存器</td></tr><tr><td>0x64</td><td>写</td><td>命令寄存器</td></tr></tbody></table><p>在发送命令或者写入数据之前，需要确认8042是否准备就绪，就绪标志在状态字的第1位。</p><p>打开A20 Gate的具体步骤大致如下：</p><p>1、等待8042 Input buffer为空<br>2、发送Write 8042 Output Port （P2） 命令到8042 Input buffer<br>3、等待8042 Input buffer为空<br>4、将8042 Output Port（P2） 对应字节的第2位置1，然后写入8042 Input buffer</p><p>打开A20 Gate的功能是在<code>boot/bootasm.S</code>中实现的，下面结合相关代码来分析：代码分为<code>seta20.1</code>和<code>seta20.2</code>两部分，其中seta20.1是往端口0x64写数据0xd1，告诉CPU我要往8042芯片的P2端口写数据；seta20.2是往端口0x60写数据0xdf，从而将8042芯片的P2端口设置为1. 两段代码都需要先读0x64端口的第2位，确保输入缓冲区为空后再进行后续写操作。</p><pre class="line-numbers language-c++"><code class="language-c++">seta20.1:            //等待8042键盘控制器不忙    inb $0x64, %al   //从0x64端口中读入一个字节到al中               testb $0x2, %al  //测试al的第2位    jnz seta20.1     //al的第2位为0，则跳出循环    movb $0xd1, %al  //将0xd1写入al中                             outb %al, $0x64  //将0xd1写入到0x64端口中                          seta20.2:            //等待8042键盘控制器不忙    inb $0x64, %al   //从0x64端口中读入一个字节到al中               testb $0x2, %al  //测试al的第2位    jnz seta20.2     //al的第2位为0，则跳出循环    movb $0xdf, %al  //将0xdf入al中                             outb %al, $0x60  //将0xdf入到0x64端口中，打开A20                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第三步：加载段表GDT"><a href="#第三步：加载段表GDT" class="headerlink" title="第三步：加载段表GDT"></a>第三步：加载段表GDT</h4><p> <strong>如何初始化GDT表？</strong><br>1、<code>boot/bootasm.S</code>中的<code>lgdt</code>把全局描述符表的起始地址和界限（ <code>gdt</code>的大小-1）共8个字节加载到全局描述符表寄存器GDTR中。从代码中可以看到全局描述符表的大小为<code>0x17 + 1 = 0x18</code>，也就是24字节。由于全局描述符表每项大小为8字节，因此一共有3项，而第一项是空白项，所以全局描述符表中只有两个有效的段描述符，分别对应代码段和数据段。</p><p>2、<code>gdtdesc</code>指出了全局描述符表（ 可以看成是段描述符组成的一个数组） 的起始位置在<code>gdt</code>符号处， 而<code>gdt</code>符号处放置了三个段描述符的信息，每个段描述符占8个字节，第一个是NULL段描述符， 没有意义， 表示全局描述符表的开始， 紧接着是代码段描述符（ 位于全局描述符表的<code>0x8</code>处的位置），具有可读（ <code>STA_R</code>） 和可执行（ <code>STA_X</code>） 的属性， 并且段起始地址为0， 段大小为4GB； 接下来是数据段描述符（ 位于全局描述符表的0x10处的位置） ， 具有可读（ <code>STA_R</code>） 和可写（<code>STA_W</code>） 的属性， 并且段起始地址为0，段大小为4GB。  </p><pre class="line-numbers language-c++"><code class="language-c++">// Bootstrap GDT.p2align 2                                          # force 4 byte alignmentgdt:    SEG_NULLASM                                     # null seg    SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)           # code seg for bootloader and kernel    SEG_ASM(STA_W, 0x0, 0xffffffff)                 # data seg for bootloader and kernel<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第四步：Q3-3-如何能和进入保护模式设置cr0上的保护位"><a href="#第四步：Q3-3-如何能和进入保护模式设置cr0上的保护位" class="headerlink" title="第四步：Q3.3.如何能和进入保护模式设置cr0上的保护位"></a>第四步：Q3.3.如何能和进入保护模式设置cr0上的保护位</h4><p>指令<code>movl %eax， %cr0</code>把保护模式开启位置为1， 这时已经做好进入80386保护模式的准备， 但还没有进入80386保护模式 。cr0寄存器是Intel x86处理器上用于控制处理器行为的寄存器，<code>cr0</code>的第0位用来设置CPU是否开启保护模式</p><pre class="line-numbers language-c++"><code class="language-c++">movl %cr0, %eax       //加载cro到eaxorl $CR0_PE_ON, %eax  //将eax的第0位置为1movl %eax, %cr0       //将cr0的第0位置为1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第五步：调转到保护模式代码"><a href="#第五步：调转到保护模式代码" class="headerlink" title="第五步：调转到保护模式代码"></a>第五步：调转到保护模式代码</h4><p>使用 <code>ljmp</code> 命令跳转至32位代码段起始地址）：将CS寄存器设置为代码段选择子，进入32位保护模式，依次初始化 <code>ds、es、fs、gs、ss</code>，并使 <code>ebp</code> 为 0，<code>esp</code> 为 start（<code>0x7c00</code>），调用 <code>bootmain</code> 函数</p><pre class="line-numbers language-c++"><code class="language-c++">  movw $PROT_MODE_DSEG, %ax                       # Our data segment selector    7c32:    66 b8 10 00              mov    $0x10,%ax    movw %ax, %ds                                   # -> DS: Data Segment    7c36:    8e d8                    mov    %eax,%ds    movw %ax, %es                                   # -> ES: Extra Segment    7c38:    8e c0                    mov    %eax,%es    movw %ax, %fs                                   # -> FS    7c3a:    8e e0                    mov    %eax,%fs    movw %ax, %gs                                   # -> GS    7c3c:    8e e8                    mov    %eax,%gs    movw %ax, %ss                                   # -> SS: Stack Segment    7c3e:    8e d0                    mov    %eax,%ss<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习4：分析bootloader加载ELF格式的OS的过程"><a href="#练习4：分析bootloader加载ELF格式的OS的过程" class="headerlink" title="练习4：分析bootloader加载ELF格式的OS的过程"></a>练习4：分析bootloader加载ELF格式的OS的过程</h2><p>  通过阅读bootmain.c，了解bootloader如何加载ELF文件。通过分析源代码和通过qemu来运行并调试bootloader&amp;OS，理解：</p><ul><li>1.bootloader如何读取硬盘扇区的？</li><li>2.bootloader是如何加载ELF格式的OS？</li></ul><blockquote><p>问题4.1：bootloader如何读取硬盘扇区的？</p></blockquote><h5 id="实验背景"><a href="#实验背景" class="headerlink" title="实验背景"></a>实验背景</h5><p>​        bootloader让80386处理器进入保护模式后， 下一步的工作就是从硬盘上加载并运行OS。 考虑到实现的简单性， bootloader的访问硬盘都是LBA模式的PIO（ Program IO） 方式， 即所有的I/O操作是通过CPU访问硬盘的I/O地址寄存器完成。<br>一般主板有2个IDE通道（ 硬盘的I/O控制器） ， 每个通道可以接2个IDE硬盘。 第一个IDE通道通过访问I/O地址0x1f0-0x1f7来实现， 第二个IDE通道通过访问0x170-0x17f实现。 每个通道的主从盘的选择通过第6个I/O偏移地址寄存器来设置。</p><p>​        硬盘共有8个IO地址寄存器，其中第1个存储数据，第8个存储状态和命令，第3个存储要读写的扇区数，第4~7个存储要读写的起始扇区的编号（共28位）。下述表格所显示的即为0x1f0～0x1f7所对应的功能：</p><table><thead><tr><th>I/O地址串口</th><th>功能</th></tr></thead><tbody><tr><td>0x1f0</td><td>读数据，当0x1f7不为忙状态时，可以读</td></tr><tr><td>0x1f1</td><td>可获得详细的错误信息</td></tr><tr><td>0x1f2</td><td>每次读写前需要读写的扇区数</td></tr><tr><td>0x1f3</td><td>如果是LBA格式，就是读LBA参数的0~7位</td></tr><tr><td>0x1f4</td><td>如果是LBA格式，就是读LBA参数的8~15位</td></tr><tr><td>0x1f5</td><td>如果是LBA格式，就是读LBA参数的16~23位</td></tr><tr><td>0x1f6</td><td>第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td></tr><tr><td>0x1f7</td><td>状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td></tr></tbody></table><p>bootloader读取扇区的功能是在boot/bootmain.c的readsect函数中实现的，先贴代码： </p><pre class="line-numbers language-c++"><code class="language-c++">#define SECTSIZE        512#define ELFHDR          ((struct elfhdr *)0x10000)      // scratch space/* waitdisk - wait for disk ready */1.等待硬盘空闲。waitdisk的函数实现只有一行：while ((inb(0x1F7) & 0xC0) != 0x40)，意思是不断查询读0x1F7端口的最高两位，直到最高位为0、次高位为1（即磁盘空闲）才返回。附录:inb 从I/O端口读取一个字节(BYTE, HALF-WORD) ;    outb 向I/O端口写入一个字节（BYTE, HALF-WORD） ;static void waitdisk(void) {    while ((inb(0x1F7) & 0xC0) != 0x40)        /* do nothing */;}/* readsect - read a single sector at @secno into @dst */static void readsect(void *dst, uint32_t secno) {    // wait for disk to be ready    waitdisk();--------------------------------------------------------0x1F2 写入扇区数0x1F3 LBA 0~70x1F4 LBA 8~150x1F5 LBA 16~230x1F6 LBA 7~4位为1110 表示LBA模式 24~27 0x1F7 0x20 读命令硬盘空闲后，发出读取扇区的命令，对应的命令字为0x20，放在0x1F7寄存器中, 说明我要开始读扇区了；读取的扇区数为1，放在0x1F2寄存器中；读取的扇区起始编号共28位，分成4部分依次放在0x1F3~0x1F6寄存器中。一次从 0x1F0 读入 2个字 4个字节 读入512字节 需要 128次--------------------------------------------------------    outb(0x1F2, 1);                         // count = 1    outb(0x1F3, secno & 0xFF);    outb(0x1F4, (secno >> 8) & 0xFF);    outb(0x1F5, (secno >> 16) & 0xFF);    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);    outb(0x1F7, 0x20);                      // cmd 0x20 - read sectors    // wait for disk to be ready    waitdisk();    // read a sector    insl(0x1F0, dst, SECTSIZE / 4);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> readsect函数会使用到的内联汇编定义 :</p><pre class="line-numbers language-c++"><code class="language-c++">从port端口读取一个byte，返回这个读取的值。 static inline uint8_tinb(uint16_t port) {    uint8_t data;    asm volatile ("inb %1, %0" : "=a" (data) : "d" (port) : "memory");    return data;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>根据代码可以得出读取硬盘扇区的步骤：</strong></p><p>1、等待硬盘空闲</p><p>waitdisk的函数实现只有一行：while ((inb(0x1F7) &amp; 0xC0) != 0x40)，意思是不断查询读0x1F7寄存器的最高两位，直到最高位为0、次高位为1（这个状态应该意味着磁盘空闲）才返回。</p><pre class="line-numbers language-c++"><code class="language-c++">static void waitdisk(void) {    while ((inb(0x1F7) & 0xC0) != 0x40)        /* do nothing */;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、硬盘空闲后，发出读取扇区的命令，对应的命令字为0x20，放在0x1F7寄存器中, 说明我要开始读扇区了；读取的扇区数为1，放在0x1F2寄存器中；读取的扇区起始编号共28位，分成4部分依次放在0x1F3~0x1F6寄存器中。</p><pre class="line-numbers language-c++"><code class="language-c++">static void readsect(void *dst, uint32_t secno) {    // wait for disk to be ready    waitdisk();    outb(0x1F2, 1);                         // count = 1    outb(0x1F3, secno & 0xFF);    outb(0x1F4, (secno >> 8) & 0xFF);    outb(0x1F5, (secno >> 16) & 0xFF);    outb(0x1F6, ((secno >> 24) & 0xF) | 0xE0);    outb(0x1F7, 0x20);    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>3、发出命令后，再次等待硬盘空闲。</p><pre class="line-numbers language-c++"><code class="language-c++">  waitdisk();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、硬盘再次空闲后，开始从0x1F0寄存器中读数据，insl函数一次读4个字节， 因此这里SECTIZE需要除以4</p><pre class="line-numbers language-c++"><code class="language-c++">  insl(0x1F0, dst, SECTSIZE / 4);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>其中insl的内联函数为：</p><pre class="line-numbers language-c++"><code class="language-c++">static inline voidinsl(uint32_t port, void *addr, int cnt) {    asm volatile (            "cld;"            "repne; insl;"            : "=D" (addr), "=c" (cnt)            : "d" (port), "0" (addr), "1" (cnt)            : "memory", "cc");}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>readseg</code>简单包装了<code>readsect</code>，可以从设备读取任意长度的内容</p><pre class="line-numbers language-c++"><code class="language-c++">/* * * readseg - read @count bytes at @offset from kernel into virtual address @va, * might copy more than asked. * */ 包装一下 可以读取任意长度的内容 static void readseg(uintptr_t va, uint32_t count, uint32_t offset) {    uintptr_t end_va = va + count;    // round down to sector boundary    va -= offset % SECTSIZE;    // translate from bytes to sectors; kernel starts at sector 1    uint32_t secno = (offset / SECTSIZE) + 1;    // If this is too slow, we could read lots of sectors at a time.    // We'd write more to memory than asked, but it doesn't matter --    // we load in increasing order.    for (; va < end_va; va += SECTSIZE, secno ++) {        readsect((void *)va, secno);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>readseg</code>函数：</p><p>在<code>bootmain.c</code>文件中，关于读取硬盘扇区的函数有两个：<code>readseg</code>和<code>readsect</code>，其中<code>readseg</code>会调用<code>readsect</code>。<br><code>readseg(uintptr_t va, uint32_t count, uint32_t offset)</code>函数会从内核的offset位置（因为内核起始位置为一个扇区的起始位置，所以offset % 512 也就是 offset这个位置相对于这个扇区的offset）读取count个字节，放置到va所对应的虚拟内存位置。 </p><p><code>va -= offset % SECTSIZE</code>; 这条语句表明我们读字节必须从扇区头部开始读；所以将va减去offset，最后的效果是会多读一点进来（va前面的），但是没有关系。<br><code>secno</code>是调用<code>readsect</code>函数必须要求的扇区号。<br>接下来会调用<code>readsect</code>函数进行扇区读取，一次读取一个扇区（512字节）到对应的Virtual Address，直到读完。因为读取只能以扇区为单位，所以可能会读多，但是没关系。 </p><blockquote><p> 问题4.2.：bootloader如何加载ELF格式的OS</p></blockquote><p>​         ucore通过gcc编译和ld链接， 形成了ELF格式执行文件kernel（ 位于bin目录下）， 这样kernel的内部组成与一般的应用程序差别不大。 一般而言， 一个执行程序的内容是至少由 bss段、 data段、text段三大部分组成。 bootloader会访问ELF(Executable and linking format)格式的ucore， 并把ucore加载到内存中。简单地说， bootloader通过解析ELF格式的ucore， 可以了解到ucore的代码段（ 机器码） /数据段（ 初始化的变量） 等在文件中的位置和大小， 以及应该放到内存中的位置； 可了解ucore的BSS段（ 未初始化的变量， 具体内容没有保存在文件中） 的内存位置和大小。 这样bootloader就可以把ucore正确地放置到内存中， 便于ucore的正确执行。</p><pre class="line-numbers language-c++"><code class="language-c++">/* bootmain - the entry of bootloader */void bootmain(void) {    // read the 1st page off disk    这里读入了 512 * 8 个字节 ELF头    readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);    // is this a valid ELF?    根据读进来的文件的头部 魔数 判断是否为合法 ELF文件    if (ELFHDR->e_magic != ELF_MAGIC) {        goto bad;    }    struct proghdr *ph, *eph;    // load each program segment (ignores ph flags)    读取每个代码段 到指定的地方    ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);    eph = ph + ELFHDR->e_phnum;    for (; ph < eph; ph ++) {        readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);    }    // call the entry point from the ELF header    // note: does not return    进入内核    ((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();bad:真实硬件中 并不会有设备连接到 0x8A00 端口 故相当于啥也没做    outw(0x8A00, 0x8A00);    outw(0x8A00, 0x8E00);    /* do nothing */    while (1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>1、 ELF头是ELF文件的一个头，用来识别文件类型，以及标注ELF文件内各个段的位置。回到bootmain函数，在ucore中，<code>ELFHDR</code>被定义为一个指向<code>elfhdr</code>的指针， 值为0x10000， <code>readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0)</code>意思就是把硬盘中的bin/kernel文件读入8个扇区 ，并且把读进来的内核ELF文件加载到内存地址为0x10000位置，目的是为了读取解析kernel文件的ELF Header信息。</p><p>2、校验ELF Header的e_magic字段，以确保这是一个ELF文件</p><pre class="line-numbers language-c++"><code class="language-c++">if (ELFHDR->e_magic != ELF_MAGIC) {    goto bad;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>3、读取ELF Header的e_phoff字段，与ELFHDR的地址相加得到Program Header表的起始地址；</p><pre class="line-numbers language-c++"><code class="language-c++">ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR->e_phoff);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、读取ELF Header的e_phnum字段，得到Program Header表的元素数目。</p><pre class="line-numbers language-c++"><code class="language-c++">eph = ph + ELFHDR->e_phnum;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、遍历Program Header表中的每个元素，得到每个Segment在文件中的偏移、要加载到内存中的位置（虚拟地址）及Segment的长度等信息，并通过磁盘I/O进行加载</p><pre class="line-numbers language-c++"><code class="language-c++">for (; ph < eph; ph ++) {    readseg(ph->p_va & 0xFFFFFF, ph->p_memsz, ph->p_offset);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5、加载完毕，通过ELF Header的e_entry得到内核的入口地址，并跳转到该地址开始执行内核代码</p><pre class="line-numbers language-c++"><code class="language-c++">((void (*)(void))(ELFHDR->e_entry & 0xFFFFFF))();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="练习5：实现函数调用堆栈跟踪函数"><a href="#练习5：实现函数调用堆栈跟踪函数" class="headerlink" title="练习5：实现函数调用堆栈跟踪函数"></a>练习5：实现函数调用堆栈跟踪函数</h2><blockquote><p> 问题5.1：在lab1中完成kdebug.c中函数print_stackframe的实现，可以通过函数print_stackframe来跟踪函数调用堆栈中记录的返回地址。</p></blockquote><p>  首先我们需要了解GCC生成的C函数调用过程：</p><ol><li>调用函数为了传递参数给被调用函数， 需要执行0到n个push指令把函数参数入栈， 然后会执行一个call指令， 在call指令内部执行过程中， 还把返回地址（ 即CALL指令下一条指令的地址） 也入栈了。</li><li>GCC编译器会在每个函数的起始部分插入类似如下指令(可参看obj/kernel.asm文件内容)</li></ol><pre class="line-numbers language-c++"><code class="language-c++">1. push %ebp2. mov %esp,%ebp3. sub $NUM,%esp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在ucore执行到一个函数的函数体时， 已经有以下数据顺序入栈： 调用函数的参数， 函数返回地址。<br>由此得到如下图的栈结构 ：</p> <img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172550.jpg" alt="img" style="zoom:75%;">                               <p>其中：</p><p><code>ESP</code>：栈指针寄存器(extended stack pointer)，值为内存地址，指向系统栈最上面一个函数栈帧的栈顶<br><code>EBP</code>：基址指针寄存器(extended base pointer)，值为内存地址，指向系统栈最上面一个函数栈帧的底部<br>函数栈帧：ESP和EBP之间的内存空间为当前函数栈帧，EBP标识了当前栈帧的底部，ESP标识了当前函数栈帧的顶部。</p><p>​         到此时为止，<code>ebp</code>寄存器处于函数调用关系链中一个非常重要的地位。 <code>ebp</code>寄存器中存储着栈中的一个地址（ 栈帧分界处） ， 此地址是“老”<code>ebp</code>入栈后的栈顶。 那么以该该地址为基准， 向高地址方向（ 即栈底方向） 能获取返回地址、 参数值， 向低地址方向（ 栈顶方向） 能获取函数局部变量值， 而该地址处又存放着上一层函数调用时的ebp值。 由于ebp中的地址处总是“上一层函数调用时的<code>ebp</code>值”， 这样， 就能通过把<code>ebp</code>的内容作为寻找上一个调用函数的栈帧的指针， 如此形成递归， 直至到达栈底。这就可找到整个的函数调用栈，这也是<code>kdebug.c</code>中<code>print_stackframe</code>函数的实现内容，将栈中有意义的数据读取出来即可。 </p><p>先查看两个函数定义：</p><p><code>read_ebp</code>:读取当前函数栈帧下<code>ebp</code>寄存器的值，其值对应的是调用栈的内存地址，该内存地址保存着旧的ebp的值</p><pre class="line-numbers language-c++"><code class="language-c++">static inline uint32_tread_ebp(void) {    uint32_t ebp;    asm volatile ("movl %%ebp, %0" : "=r" (ebp));    return ebp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>read_eip</code>:<code>eip</code>的值是<code>ebp</code>寄存器+4计算得到内存地址中保存的值，新函数执行完成之后的返回地址，也就是原来函数调用新函数对应指令的下一条指令的地址。</p><pre class="line-numbers language-c++"><code class="language-c++">read_eip(void) {    uint32_t eip;    asm volatile("movl 4(%%ebp), %0" : "=r" (eip));    return eip;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="函数链式调用的过程："><a href="#函数链式调用的过程：" class="headerlink" title="函数链式调用的过程："></a>函数链式调用的过程：</h5><p>1、首先使用<code>read_ebp</code>和<code>read_eip</code>函数获取当前stack frame的base pointer以及<code>call read_eip</code>这条指令下一条指令的地址，存入<code>ebp</code>, <code>eip</code>两个临时变量中；</p><p>2、接下来使用<code>cprint</code>函数打印出<code>ebp</code>, <code>eip</code>的数值；</p><p>3、接下来打印出当前栈帧对应的函数可能的参数，根据c语言编译到x86汇编的约定，可以知道参数存放在<code>ebp+8</code>指向的内存上（栈），并且第一个、第二个、第三个…参数所在的内存地址分别为<code>ebp+8</code>, <code>ebp+12</code>, <code>ebp+16</code>, …，根据要求读取出当前函数的前四个参数(用可能这些参数并不是全都存在，视具体函数而定)，并打印出来；</p><p>4、使用<code>print_debuginfo</code>打印出当前函数的函数名；</p><p>5、根据动态链查找当前函数的调用者(caller)的栈帧, 根据约定，<code>caller</code>的栈帧的base pointer存放在<code>callee</code>的<code>ebp</code>指向的内存单元，将其更新到<code>ebp</code>临时变量中，同时将<code>eip</code>(代码中对应的变量为ra)更新为调用当前函数的指令的下一条指令所在位置（return address），其根据约定存放在<code>ebp+4</code>所在的内存单元中；</p><p>6、如果<code>ebp</code>非零并且没有达到规定的STACKFRAME DEPTH的上限，则跳转到2，继续循环打印栈上栈帧和对应函数的信息；</p><p><strong>函数实现：</strong></p><pre class="line-numbers language-c++"><code class="language-c++">voidprint_stackframe(void) {     //调用read ebp访问当前ebp的值，数据类型为32位。    //此时eip指向了args:[ebp+4]的位置 此处存放着返回地址    uint32_t ebp = read_ebp(), eip = read_eip();    int i, j;    for (i = 0; ebp != 0 && i < STACKFRAME_DEPTH; i ++) {        cprintf("ebp:0x%08x eip:0x%08x args:", ebp, eip);        //此时args指向了args:[ebp+8]的位置 此处存放着参数        uint32_t *args = (uint32_t *)ebp + 2;        //依次打印调用函数的参数1 2 3 4        for (j = 0; j < 4; j ++) {            //因为使用的是栈数据结构，因此可以直接根据ebp就能读取到各个栈帧的地址和值，            //ebp+4处为返回地址，ebp+8处为第一个参数值（最后一个入栈的参数值，对应32位系统），            //ebp-4处为第一个局部变量，ebp处为上一层 ebp 值。            cprintf("0x%08x ", args[j]);        }        cprintf("\n");        //打印eip以及ebp相关的信息        print_debuginfo(eip - 1);        eip = ((uint32_t *)ebp)[1];        ebp = ((uint32_t *)ebp)[0];    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">ebp:0x00007b08 eip:0x001009b6 args:0x00010094 0x00000000 0x00007b38 0x00100097     kern/debug/kdebug.c:305: print_stackframe+21ebp:0x00007b18 eip:0x00100ca5 args:0x00000000 0x00000000 0x00000000 0x00007b88     kern/debug/kmonitor.c:125: mon_backtrace+10ebp:0x00007b38 eip:0x00100097 args:0x00000000 0x00007b60 0xffff0000 0x00007b64     kern/init/init.c:38: grade_backtrace2+33ebp:0x00007b58 eip:0x001000c0 args:0x00000000 0xffff0000 0x00007b84 0x00000029     kern/init/init.c:43: grade_backtrace1+38ebp:0x00007b78 eip:0x001000de args:0x00000000 0x00100000 0xffff0000 0x0000001d     kern/init/init.c:48: grade_backtrace0+23ebp:0x00007b98 eip:0x00100103 args:0x0010369c 0x00103680 0x0000130a 0x00000000     kern/init/init.c:53: grade_backtrace+34ebp:0x00007bc8 eip:0x00100055 args:0x00000000 0x00000000 0x00000000 0x00010094     kern/init/init.c:18: kern_init+84ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8     <unknow>: -- 0x00007d67 --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后一行是<code>ebp:0x00007bf8 eip:0x00007d68 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</code>，共有ebp，eip和args三类参数，下面分别给出解释：</p><p>栈中内存的图大概长这样:</p><pre><code>高地址内核代码段[栈中内存地址-&gt;内存地址中的数据]//这边开始是`bootmain`函数的栈帧0x00007c00-&gt;栈底0x00006bfc-&gt;返回地址(`eip:0x00007d68`,  `call *%eax`的下一条指令地址 )//这边开始是`kern_init`函数的栈帧0x00007bf8-&gt;`bootmain`函数的旧的ebp值局部变量.....`esp`寄存器的值//新的函数的栈帧低地址</code></pre><h5 id="1、ebp：0x00007bf8"><a href="#1、ebp：0x00007bf8" class="headerlink" title="1、ebp：0x00007bf8"></a>1、<code>ebp</code>：<code>0x00007bf8</code></h5><p>最后一行输出的<code>ebp</code>为<code>0x00007bf8</code>，其对应的是第一个使用堆栈的函数，<code>bootmain.c</code>中的<code>bootmain</code>栈帧中<code>ebp</code>寄存器的值</p><p><code>bootloader</code>设置的堆栈从<code>0x7c00</code>开始，使用<code>call bootmain</code>转入<code>bootmain</code>函数，<code>call</code>指令把<code>bootloader</code>函数调用<code>bootmain</code>函数对应的指令的下一条指令的地址压栈，再将当前旧的<code>ebp</code>寄存器的值压栈，所以此时<code>esp</code>寄存器的值为<code>0x7c00-0x8=0x00007bf8</code>。在<code>bootmain</code>函数入口处，有<code>mov %esp %ebp</code>指令，故在<code>bootmain</code>栈帧中<code>ebp寄存器</code>为<code>0x00007bf8</code>，所以<code>bootmain</code>中<code>ebp</code>寄存器的值为<code>0x7bf8</code>。</p><pre class="line-numbers language-ASM"><code class="language-ASM">7d66:    ff d0                    call   *%eax7d68:    b8 00 8a ff ff           mov    $0xffff8a00,%eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172551.png" alt="1586751387513" style="zoom:75%;"><h5 id="2、eip-0x00007d68："><a href="#2、eip-0x00007d68：" class="headerlink" title="2、eip:0x00007d68："></a>2、<code>eip:0x00007d68</code>：</h5><p><code>eip</code>的值是<code>kern_init</code>函数执行完成之后的返回地址，也就是<code>bootmain</code>函数调用<code>kern_init</code>对应的指令的下一条指令的地址。</p><h5 id="3、args-0xc031fcfa-0xc08ed88e-0x64e4d08e-0xfa7502a8"><a href="#3、args-0xc031fcfa-0xc08ed88e-0x64e4d08e-0xfa7502a8" class="headerlink" title="3、args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8"></a>3、<code>args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8</code></h5><p>​         一般来说，args存放的4个dword是对应4个输入参数的值。但这里比较特殊，由于<code>bootmain</code>函数调用<code>kern_init</code>并没传递任何输入参数，并且栈顶的位置恰好在<code>bootloader</code>第一条指令存放的地址的上面，而<code>args</code>恰好是<code>kern_init</code>的<code>ebp</code>寄存器指向的栈顶往上第2~5个单元，因此<code>args</code>存放的就是<code>bootloader</code>指令的前16个字节！可以对比<code>obj/bootblock.asm</code>文件来验证（验证时要注意系统是小端字节序）</p><pre class="line-numbers language-c++"><code class="language-c++">00007c00 <start>:7c00: fa cli7c01: fc cld7c02: 31 c0 xor %eax,%eax      //args[0]:0xc031fcfa7c04: 8e d8 mov %eax,%ds7c06: 8e c0 mov %eax,%es       //args[1]:0xc08ed88e7c08: 8e d0 mov %eax,%ss7c0a: e4 64 in $0x64,%al       //args[1]:0x64e4d08e7c0c: a8 02 test $0x2,%al7c0e: 75 fa jne 7c0a <seta20.1>       //args[3]:0xfa7502a8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="练习6：完善中断初始化和处理"><a href="#练习6：完善中断初始化和处理" class="headerlink" title="练习6：完善中断初始化和处理"></a>练习6：完善中断初始化和处理</h2><blockquote><p>问题6.1：中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p></blockquote><p> 在保护模式下， 中断门描述符表（ IDT） 中的每个表项由8个字节组成， 其中的每个表项叫做一个门描述符（ Gate Descriptor） ,“门”的含义是指当中断发生时必须先访问这些“门”， 能够“开门”（ 即将要进行的处理需通过特权检查， 符合设定的权限等约束） 后， 然后才能进入相应的处理程序。 而门描述符则描述了“门”的属性（ 如特权级、 段内偏移量等） 。</p><p> <strong>在IDT中， 可以包含如下3种类型的系统段描述符：</strong><br><strong>中断门描述符（ Interrupt-gate descriptor）</strong> ： 用于中断处理， 其类型码为110， 中断门包含了一个外设中断或故障中断的处理程序所在段的选择子和段内偏移量。 当控制权通过中断门进入中断处理程序时， 处理器清IF标志， 即关中断， 以避免嵌套中断的发生。 中断门中的DPL（ Descriptor Privilege Level） 为0， 因此用户态的进程不能访问中断门。 所有的中断处理程序都由中断门激活， 并全部限制在内核态。<br><strong>陷阱门描述符（ Trap-gate descriptor）</strong> ： 用于系统调用， 其类型码为111， 与中断门类似，    其唯一的区别是， 控制权通过陷阱门进入处理程序时维持IF标志位不变， 也就是说， 不关中断。<br><strong>任务门描述符（ Task-gate descriptor） 和调用门描述符（ Call-gate descriptor）</strong>  </p><p>中断描述符表一个表项占8个字节，其结构如下：</p><pre class="line-numbers language-c++"><code class="language-c++">/* Gate descriptors for interrupts and traps */struct gatedesc {    unsigned gd_off_15_0 : 16;        // low 16 bits of offset in segment    unsigned gd_ss : 16;            // segment selector    unsigned gd_args : 5;            // # args, 0 for interrupt/trap gates    unsigned gd_rsv1 : 3;            // reserved(should be zero I guess)    unsigned gd_type : 4;            // type(STS_{TG,IG32,TG32})    unsigned gd_s : 1;                // must be 0 (system)    unsigned gd_dpl : 2;            // descriptor(meaning new) privilege level    unsigned gd_p : 1;                // Present    unsigned gd_off_31_16 : 16;        // high bits of offset in segment};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/the-time-is-limitted/blog-img/raw/master/img/20200715172552.png" alt="1586665514152" style="zoom:75%;"><pre class="line-numbers language-c+bit"><code class="language-c+bit">bit 47…32: 属性信息，包括DPL、P flag等bit 31…16: Segment selectorbit 15…0: offset 15…0其中第16 ~ 32位是段选择子，用于索引全局描述符表GDT来获取中断处理代码对应的段地址，再加上第0 ~ 15、48 ~ 63位构成的偏移地址，即可得到中断处理代码的入口。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题6.2：编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</p></blockquote><p>中断向量和中断服务例程的对应关系主要是由IDT（ 中断门描述符表） 来描述。 操作系统在IDT中设置好各种中断向量对应的中断描述符， 而中断描述符指出了中断服务例程的起始地址， 留待CPU在产生中断后查询对应中断服务例程的起始地址。 而IDT本身的起始地址保存在IDTR寄存器中。  </p><p>对于trap.c函数的实现主要分为下面几个步骤：</p><p> ucore操作系统如果要正确处理各种不同的中断事件， 就需要安排应该由哪个中断服务例程负责处理特定的中断事件。 系统将所有的中断事件统一进行了编号（ 0～ 255） ， 这个编号称为中断号或中断向量。<br>1、为了完成中断号和中断服务例程起始地址的对应关系， 首先需要建立256个中断处理例程的入口地址。 为此， 通过一个 C程序 tools/vector.c 生成了一个文件vectors.S， 在此文件中的__vectors地址处开始处连续存储了256个中断处理例程的入口地址数组， 且在此文件中的每个中断处理例程的入口地址处， 实现了中断处理过程的第一步初步处理。有了中断服务例程的起始地址， 就可以建立对应关系了， 这部分的实现在trap.c文件中的idt_init</p><p>2、idt_init函数的功能是初始化IDT表。IDT表中每个元素均为门描述符，记录一个中断向量的属性，包括中断向量对应的中断处理函数的段选择子/偏移量、门类型（是中断门还是陷阱门）、DPL等。因此，初始化IDT表实际上是初始化每个中断向量的这些属性。 </p><p>3、中断处理函数的段选择子及偏移量的设置要参考kern/trap/vectors.S文件：由该文件可知，所有中断向量的中断处理函数地址均保存在__vectors数组中，该数组中第i个元素对应第i个中断向量的中断处理函数地址。而且由文件开头可知，中断处理函数属于.text的内容。因此，中断处理函数的段选择子即.text的段选择子GD_KTEXT。从kern/mm/pmm.c可知.text的段基址为0，因此中断处理函数地址的偏移量等于其地址本身。</p><p>4、完成IDT表的初始化后，还要使用lidt命令将IDT表的起始地址加载到IDTR寄存器，其中中断门描述符表寄存器 (Interrupt Descriptor Table Register， IDTR)中保存着IDT表的首地址，指向一张包含中断处理子程序入口点的表（ IDT）  </p><pre class="line-numbers language-c++"><code class="language-c++">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */void idt_init(void) {    extern uintptr_t __vectors[];  //保存在vectors.S中的256个中断处理例程的入口地址数组    int i;    /* along: how to set istrap and dpl? */   //使用SETGATE宏，对中断描述符表中的每一个表项进行设置    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) { //IDT表项的个数    //在中断门描述符表中通过建立中断门描述符，其中存储了中断处理例程的代码段GD_KTEXT和偏移量__vectors[i]，特权级为DPL_KERNEL。这样通过查询idt[i]就可定位到中断服务例程的起始地址。     SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);    }    SETGATE(idt[T_SWITCH_TOK], 0, GD_KTEXT,         __vectors[T_SWITCH_TOK], DPL_USER);     //建立好中断门描述符表后，通过指令lidt把中断门描述符表的起始地址装入IDTR寄存器中，从而完成中段描述符表的初始化工作。    lidt(&idt_pd);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码中SETGATE函数的实现：</p><pre class="line-numbers language-c++"><code class="language-c++">#define SETGATE(gate, istrap, sel, off, dpl) {            \    (gate).gd_off_15_0 = (uint32_t)(off) & 0xffff;        \    (gate).gd_ss = (sel);                                \    (gate).gd_args = 0;                                    \    (gate).gd_rsv1 = 0;                                    \    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \    (gate).gd_s = 0;                                    \    (gate).gd_dpl = (dpl);                                \    (gate).gd_p = 1;                                    \    (gate).gd_off_31_16 = (uint32_t)(off) >> 16;        \}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>问题6.3：请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数</p></blockquote><p>​         trap函数只是直接调用了trap_dispatch函数，而trap_dispatch函数实现对各种中断的处理，题目要求我们完成对时钟中断的处理，实现非常简单：定义一个全局变量ticks，每次时钟中断将ticks加1，加到100后打印”100 ticks”，然后将ticks清零重新计数。代码实现如下：</p><pre class="line-numbers language-c++"><code class="language-c++">case IRQ_OFFSET + IRQ_TIMER:    if (((++ticks) % TICK_NUM) == 0) {        print_ticks();        ticks = 0;      }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Ucore </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ucore </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis那么快的背后</title>
      <link href="/2020/02/16/redis-na-me-kuai-de-bei-hou/"/>
      <url>/2020/02/16/redis-na-me-kuai-de-bei-hou/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis 内置了复制（Replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（Transactions） 和不同级别的磁盘持久化（Persistence），并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（High Availability）。</p><a id="more"></a><h2 id="一、I-O-多路复用（-I-O-Multiplexing）"><a href="#一、I-O-多路复用（-I-O-Multiplexing）" class="headerlink" title="一、I/O 多路复用（ I/O Multiplexing）"></a>一、I/O 多路复用（ I/O Multiplexing）</h2><h3 id="1-1、传统-I-O-数据拷贝"><a href="#1-1、传统-I-O-数据拷贝" class="headerlink" title="1.1、传统 I/O 数据拷贝"></a>1.1、传统 I/O 数据拷贝</h3><p>当应用程序执行 read 系统调用读取文件描述符（FD）的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据。如果数据不存在，则先将数据从磁盘加载数据到内核缓冲区中，再从内核缓冲区拷贝到用户进程的页内存中。（两次拷贝，两次 user 和 kernel 的上下文切换）。</p><p>为了解决阻塞的问题，我们有几个思路。<br>1、在服务端创建多个线程或者使用线程池，但是在高并发的情况下需要的线程会很多，系统无法承受，而且创建和释放线程都需要消耗资源。<br>2、由请求方定期轮询，在数据准备完毕后再从内核缓存缓冲区复制数据到用户空间（非阻塞式 I/O），这种方式会存在一定的延迟。</p><h2 id="1-2、redis是怎么使用单线程去处理多个客户端请求？"><a href="#1-2、redis是怎么使用单线程去处理多个客户端请求？" class="headerlink" title="1.2、redis是怎么使用单线程去处理多个客户端请求？"></a>1.2、redis是怎么使用单线程去处理多个客户端请求？</h2><p>答案：I/O 多路复用（ I/O Multiplexing）<br>I/O 指的是网络 I/O。<br>多路指的是多个 TCP 连接（Socket 或 Channel）。<br>复用指的是复用一个或多个线程。<br>它的基本原理就是不再由应用程序自己监视连接，而是由内核替应用程序监视文件描述符。</p><p> 客户端在操作的时候，会产生具有不同事件类型的 socket。在服务端，I/O 多路复<br>用程序（I/O Multiplexing Module）会把消息放入队列中，然后通过文件事件分派器（File<br>event Dispatcher），转发到不同的事件处理器中。  </p><p><img src="https://s2.ax1x.com/2020/02/26/3NfIOg.png" alt="avatar"></p><p>  多路复用有很多的实现，以 select 为例，当用户进程调用了多路复用器，进程会被阻塞。内核会监视多路复用器负责的所有 socket，当任何一个 socket 的数据准备好了，多路复用器就会返回。这时候用户进程再调用 read 操作，把数据从内核缓冲区拷贝到用户空间  </p><p>select函数原型</p><pre class="line-numbers language-c++"><code class="language-c++">#include <sys/select.h>#include <sys/time.h>#include <sys/types.h>#include <unistd.h>int select(int nfds, fd_set *readfds, fd_set *writefds,            fd_set *exceptfds, struct timeval *timeout);    nfds:         监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态    readfds：    监控有读数据到达文件描述符集合，传入传出参数    writefds：    监控写数据到达文件描述符集合，传入传出参数    exceptfds：    监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数    timeout：    定时阻塞监控时间，3种情况                1.NULL，永远等下去                2.设置timeval，等待固定时间                3.设置timeval里时间均为0，检查描述字后立即返回，轮询    struct timeval {        long tv_sec; /* seconds */        long tv_usec; /* microseconds */    };    void FD_CLR(int fd, fd_set *set);     //把文件描述符集合里fd清0    int FD_ISSET(int fd, fd_set *set);     //测试文件描述符集合里fd是否置1    void FD_SET(int fd, fd_set *set);     //把文件描述符集合里fd位置1    void FD_ZERO(fd_set *set);             //把文件描述符集合里所有位清0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++"><code class="language-c++">/* server.c */#define MAXLINE 80#define SERV_PORT 6666int main(int argc, char *argv[]){    int i, maxi, maxfd, listenfd, connfd, sockfd;    int nready, client[FD_SETSIZE];     /* FD_SETSIZE 默认为 1024 */    ssize_t n;    fd_set rset, allset;    char buf[MAXLINE];    char str[INET_ADDRSTRLEN];             /* #define INET_ADDRSTRLEN 16 */    socklen_t cliaddr_len;    struct sockaddr_in cliaddr, servaddr;    listenfd = Socket(AF_INET, SOCK_STREAM, 0);bzero(&servaddr, sizeof(servaddr));servaddr.sin_family = AF_INET;servaddr.sin_addr.s_addr = htonl(INADDR_ANY);servaddr.sin_port = htons(SERV_PORT);Bind(listenfd, (struct sockaddr *)&servaddr, sizeof(servaddr));Listen(listenfd, 20);         /* 默认最大128 */maxfd = listenfd;             /* 初始化 */maxi = -1;                    /* client[]的下标 */for (i = 0; i < FD_SETSIZE; i++)    client[i] = -1;         /* 用-1初始化client[] */FD_ZERO(&allset);FD_SET(listenfd, &allset); /* 构造select监控文件描述符集 */for ( ; ; ) {    rset = allset;             /* 每次循环时都从新设置select监控信号集 */    nready = select(maxfd+1, &rset, NULL, NULL, NULL);    if (nready < 0)        perr_exit("select error");    if (FD_ISSET(listenfd, &rset)) { /* new client connection */        cliaddr_len = sizeof(cliaddr);        connfd = Accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len);        printf("received from %s at PORT %d\n",                inet_ntop(AF_INET, &cliaddr.sin_addr, str, sizeof(str)),                ntohs(cliaddr.sin_port));        for (i = 0; i < FD_SETSIZE; i++) {            if (client[i] < 0) {                client[i] = connfd; /* 保存accept返回的文件描述符到client[]里 */                break;            }        }        /* 达到select能监控的文件个数上限 1024 */        if (i == FD_SETSIZE) {            fputs("too many clients\n", stderr);            exit(1);        }        FD_SET(connfd, &allset);     /* 添加一个新的文件描述符到监控信号集里 */        if (connfd > maxfd)            maxfd = connfd;         /* select第一个参数需要 */        if (i > maxi)            maxi = i;                 /* 更新client[]最大下标值 */        if (--nready == 0)            continue;                 /* 如果没有更多的就绪文件描述符继续回到上面select阻塞监听,                                        负责处理未处理完的就绪文件描述符 */        }        for (i = 0; i <= maxi; i++) {     /* 检测哪个clients 有数据就绪 */            if ( (sockfd = client[i]) < 0)                continue;            if (FD_ISSET(sockfd, &rset)) {                if ( (n = Read(sockfd, buf, MAXLINE)) == 0) {                    Close(sockfd);        /* 当client关闭链接时，服务器端也关闭对应链接 */                    FD_CLR(sockfd, &allset); /* 解除select监控此文件描述符 */                    client[i] = -1;                } else {                    int j;                    for (j = 0; j < n; j++)                        buf[j] = toupper(buf[j]);                    Write(sockfd, buf, n);                }                if (--nready == 0)                    break;            }        }    }    close(listenfd);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、-内存回收"><a href="#二、-内存回收" class="headerlink" title="二、 内存回收"></a>二、 内存回收</h2><h3 id="2-1、内存回收——-LRU-淘汰原理"><a href="#2-1、内存回收——-LRU-淘汰原理" class="headerlink" title="2.1、内存回收—— LRU 淘汰原理"></a>2.1、内存回收—— LRU 淘汰原理</h3><h4 id="问题1：基于一个数据结构做缓存，怎么实现-LRU——最长时间不被访问的元素在超过容量时删除？"><a href="#问题1：基于一个数据结构做缓存，怎么实现-LRU——最长时间不被访问的元素在超过容量时删除？" class="headerlink" title="问题1：基于一个数据结构做缓存，怎么实现 LRU——最长时间不被访问的元素在超过容量时删除？"></a>问题1：基于一个数据结构做缓存，怎么实现 LRU——最长时间不被访问的元素在超过容量时删除？</h4><p>常规的哈希表+双向链表<br>但存在的问题在于，基于传统的LRU算法实现Redis LRU需要额外的数据结构存储，消耗内存</p><p>Redis LRU 对传统的 LRU 算法进行了改良，通过随机采样来调整算法的精度。<br>如果淘汰策略是 LRU，则根据配置的采样值 maxmemory_samples（默认是 5 个）,<br>随机从数据库中选择 m 个 key, 淘汰其中热度最低的 key 对应的缓存数据。所以采样参数m配置的数值越大, 就越能精确的查找到待淘汰的缓存数据,但是也消耗更多的CPU计算,执行效率降低。<br>而听说 Redis LRU 算法在 sample 为 10 的情况下，已经能接近传统 LRU 算法了</p><h4 id="问题2：如何找出热度最低的数据？"><a href="#问题2：如何找出热度最低的数据？" class="headerlink" title="问题2：如何找出热度最低的数据？"></a>问题2：如何找出热度最低的数据？</h4><p>Redis 中所有对象结构都有一个 lru 字段, 且使用了 unsigned 的低 24 位，这个字段用来记录对象的热度。对象被创建时会记录 lru 值。在被访问的时候也会更新 lru 的值。</p><p>源码：server.c</p><pre class="line-numbers language-c++"><code class="language-c++">typedef struct redisObject {    unsigned type:4;    unsigned encoding:4;    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or    * LFU data (least significant 8 bits frequency    * and most significant 16 bits access time). */    int refcount;    void *ptr;} robj;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是对于访问时间的计算不是获取系统当前的时间戳，而是设置为全局变量 。Redis 中 有 个 定 时 处 理 的 函 数 serverCron ， 默 认 每 100 毫 秒 调 用 函 数updateCachedTime 更新一次全局变量的 server.lruclock 的值，它记录的是当前 unix时间戳。这样函数 lookupKey 中更新数据的 lru 热度值时,就不用每次调用系统函数 time，可以提高执行效率  Redis 中 有 个 定 时 处 理 的 函 数 serverCron ， 默 认 每 100 毫 秒 调 用 函 数updateCachedTime 更新一次全局变量的 server.lruclock 的值，它记录的是当前 unix时间戳。这样函数 lookupKey 中更新数据的 lru 热度值时,就不用每次调用系统函数 time，可以提高执行效率  </p><p>函数 estimateObjectIdleTime 评估指定对象的 lru 热度，思想就是对象的 lru 值和全局的 server.lruclock 的差值越大（越久没有得到更新）， 该对象热度越低。  </p><pre class="line-numbers language-c++"><code class="language-c++">/* Given an object returns the min number of milliseconds the object was never* requested, using an approximated LRU algorithm. */unsigned long long estimateObjectIdleTime(robj *o) {    unsigned long long lruclock = LRU_CLOCK();    if (lruclock >= o->lru) {        return (lruclock - o->lru) * LRU_CLOCK_RESOLUTION;    } else {        return (lruclock + (LRU_CLOCK_MAX - o->lru)) *LRU_CLOCK_RESOLUTION;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1、内存回收——-LFU-淘汰原理"><a href="#2-1、内存回收——-LFU-淘汰原理" class="headerlink" title="2.1、内存回收—— LFU 淘汰原理"></a>2.1、内存回收—— LFU 淘汰原理</h3><pre class="line-numbers language-c++"><code class="language-c++">typedef struct redisObject {    unsigned type:4;    unsigned encoding:4;    unsigned lru:LRU_BITS; /* LRU time (relative to global lru_clock) or    * LFU data (least significant 8 bits frequency    * and most significant 16 bits access time). */    int refcount;    void *ptr;} robj;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>  当这 24 bits 用作 LFU 时，其被分为两部分：高 16 位用来记录访问时间（低 8 位用来记录访问频率，简称 counter）。counter 是用基于概率的对数计数器实现的，8 位可以表示百万次的访问频率，对象被读写的时候，lfu 的值会被更新。  </p><h2 id="三、Redis的持久化方案"><a href="#三、Redis的持久化方案" class="headerlink" title="三、Redis的持久化方案"></a>三、Redis的持久化方案</h2><h3 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h3><p>RDB 是一个非常紧凑(compact)的文件，它保存了 redis 在某个时间点上的数据集。这种文件非常适合用于进行备份和灾难恢复。</p><p>这里就提一下bgsave，执行 bgsave 时，Redis 会在后台异步进行快照操作的同时还可以响应客户端请求。<br>具体操作是 Redis 进程执行 fork 操作创建子进程（copy-on-write），RDB 持久化过程由子进程负责，完成后自动结束。它不会记录 fork 之后后续的命令。阻塞只发生在fork 阶段，一般时间很短。</p><p>如果数据相对来说比较重要，希望将损失降到最小，则可以使用 AOF 方式进行持久</p><p>可以手动调用 lastsave 命令查看最近一次成功生成快照的时间  </p><h3 id="3-2、AOF"><a href="#3-2、AOF" class="headerlink" title="3.2、AOF"></a>3.2、AOF</h3><p> AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中，随着 Redis 不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。<br>为了解决这个问题，Redis 新增了重写机制，当 AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件 </p><p>可以使用命令 bgrewriteaof 来重写。</p><h2 id="四、Redis集群高可用下的数据分片"><a href="#四、Redis集群高可用下的数据分片" class="headerlink" title="四、Redis集群高可用下的数据分片"></a>四、Redis集群高可用下的数据分片</h2><p>  数据分片有几个关键的问题需要解决：<br>1、数据怎么相对均匀地分片<br>2、客户端怎么访问到相应的节点和数据<br>3、重新分片的过程，怎么保证正常服务  </p><p>针对Redis集群高可用下的数据分片，Redis 既没有用哈希取模，也没有用一致性哈希，而是用虚拟槽来实现的。Redis 创建了 16384 个槽（slot），每个节点负责一定区间的 slot。Redis 的每个 master 节点维护一个 16384 位（2048bytes=2KB）的位序列，比如：序列的第 0 位是 1，就代表第一个 slot 是它负责；序列的第 1 位是 0，代表第二个 slot不归它负责。当我们敲下set xx xx时候，Redis会通过对 key 用 CRC16 算法计算再%16384得到一个 slot的值，数据落到负责这个 slot 的 Redis 节点上。于是乎key 与 slot 的关系是永远不会变的，会变的只有 slot 和 Redis 节点的关系  </p><p>当然我们总有这样的需求，希望不同的key落到相同的Redis节点上，以减少网络io的次数，那么我们就可以通过</p><pre><code>set a{qs}a 1</code></pre><p>Redis 在计算槽编号的时候只会获取{}之间的字符串进行槽编号计算，  在 key 里面加入相同的{hash tag}保证上面两个不同的键被计算进入相同的槽中，这样就会落入redis集群中同一个节点中</p><h2 id="五、Redis数据与数据库数据的一致性问题"><a href="#五、Redis数据与数据库数据的一致性问题" class="headerlink" title="五、Redis数据与数据库数据的一致性问题"></a>五、Redis数据与数据库数据的一致性问题</h2><p><em><em>矛盾集中在：到底是先更新数据库，再删除缓存，还是先删除缓存，再更新数据库  </em></em></p><h3 id="5-1-先更新数据库，-再删除缓存"><a href="#5-1-先更新数据库，-再删除缓存" class="headerlink" title="5.1 先更新数据库， 再删除缓存"></a>5.1 先更新数据库， 再删除缓存</h3><p>正常情况：<br>更新数据库，成功。<br>删除缓存，成功。</p><p>异常情况：<br>1、更新数据库失败，程序捕获异常，不会走到下一步，所以数据不会出现不一致。<br>2、更新数据库成功，删除缓存失败。数据库是新数据，缓存是旧数据，发生了不一致的情况。</p><p><strong>异步更新缓存：</strong></p><p>因为更新数据库时会往 binlog 写入日志，所以我们可以通过一个服务来监听 binlog的变化（比如阿里的canal），然后在客户端完成删除 key 的操作。如果删除失败的话，再发送到消息队列。总之，对于后删除缓存失败的情况，我们的做法是不断地重试删除，直到成功。（摘自网络）</p><h3 id="5-2-先删除缓存，-再更新数据库"><a href="#5-2-先删除缓存，-再更新数据库" class="headerlink" title="5.2 先删除缓存， 再更新数据库"></a>5.2 先删除缓存， 再更新数据库</h3><p>正常情况：<br>删除缓存，成功。<br>更新数据库，成功。<br>异常情况：<br>1、删除缓存，程序捕获异常，不会走到下一步，所以数据不会出现不一致。<br>2、删除缓存成功，更新数据库失败。 因为以数据库的数据为准，所以不存在数据不一致的情况。</p><p><strong>看起来好像没问题，但是如果有程序并发操作的情况下：<br>1）线程 A 需要更新数据，首先删除了 Redis 缓存<br>2）线程 B 查询数据，发现缓存不存在，到数据库查询旧值，写入 Redis，返回<br>3）线程 A 更新了数据库<br>这个时候，Redis 是旧的值，数据库是新的值，发生了数据不一致的情况。<br>那问题就变成了：能不能让对同一条数据的访问串行化呢？代码肯定保证不了，因为有多个线程，即使做了任务队列也可能有多个服务实例。数据库也保证不了，因为会有多个数据库的连接。只有一个数据库只提供一个连接的情况下，才能保证读写的操作是串行的，或者我们把所有的读写请求放到同一个内存队列当中，但是这种情况吞吐量太低了。</strong><br>所以我们有一种延时双删的策略，在写入数据之后，再删除一次缓存。</p><p>A 线程：<br>1）删除缓存<br>2）更新数据库<br>3）休眠 500ms（这个时间，依据读取数据的耗时而定）<br>4）再次删除缓存</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
